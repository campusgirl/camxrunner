################################################################################
# This file contains the base configuration of CAMxRunner.
# A new run normally inherits a copy of this file.
# Only the most important settings are contained in this file,
# you find more in ../inc/defaults.inc. You can copy them in here and change them.
#
# Maintenance note: MUST BE KEPT UP TO DATE WITH the templates directory!
#
# Runner script for CAMx 4.42/4.51 - Configuration.
# See http://people.web.psi.ch/oderbolz/CAMxRunner
# 
# Leave the next line intact, it is used for change detection
# Version: $Id$ 
#
# Written by Daniel C. Oderbolz (CAMxRunner@psi.ch),
# Released under the Creative Commons "Attribution-Share Alike 2.5 Switzerland"
# License, (http://creativecommons.org/licenses/by-sa/2.5/ch/deed.en)
################################################################################
# Who	When		What
# dco 	02.05.2008	Created
################################################################################
# TODO: 
################################################################################
#
# All Variables (except system variables like OMP*) names start with CXR_
#
# Output File names end with OUTPUT_FILE
# Input File names end with INPUT_FILE
# Directories with _DIR
# Output directories with OUTPUT_DIR
# Executables with _EXEC
#
# Arrays of files are called OUTPUT_ARR_FILES AND INPUT_ARR_FILES
#
# Really read the documentation on Rules (http://people.web.psi.ch/oderbolz/CAMxRunner#FileRules) 
# before using them.
#
# Strings which are used as Floating point numbers, but are integer, need a trailing .
#
# Arrays must have an index 0 with a Dummy entry, we work in Fortran Land here.
#
# Also, entries in arrays which contain spaces must be protected by
# single (') quotes, because arrays are exported as space separated list

################################################################################
# Mission
################################################################################

# Quickly describe this run
CXR_MISSION=""

################################################################################
# Timespan of simulation
################################################################################

# With this flag you can indicate that already the first
# simulation day is a restart. Normally false.
# Useful for example to repeat just a part of a run.
CXR_START_WITH_RESTART=false

# The Start of the simulation in YYYY-MM-DD notation
CXR_START_DATE=2007-01-01

# The Stop of the simulation in YYYY-MM-DD notation
CXR_STOP_DATE=2007-01-15

# Must be in HHMI Format, applies just to first and last day, all others are from 0000 to 2400
CXR_START_HOUR_FIRST_DAY=0000
CXR_STOP_HOUR_LAST_DAY=2400

# Timezone (0=UTC,5=EST,6=CST,7=MST,8=PST)
CXR_TIME_ZONE=0

# The Simulation intervals in Minutes (Floats!)
CXR_MAXIMUM_TIMESTEP=15.
CXR_MET_INPUT_FREQUENCY=60.
CXR_EMS_INPUT_FREQUENCY=60.
CXR_OUTPUT_FREQUENCY=60.

################################################################################
# Geometry of simulation
################################################################################

CXR_MAP_PROJECTION=LAMBERT # (LAMBERT,POLAR,UTM,LATLON)

########################################
# Floats
########################################

# Needed for LAMBERT only
CXR_LAMBERT_CENTER_LONGITUDE=3.5   # deg (west<0south<0)
CXR_LAMBERT_CENTER_LATITUDE=47.    # deg (west<0south<0)
CXR_LAMBERT_TRUE_LATITUDE1=46.     # deg (west<0south<0)
CXR_LAMBERT_TRUE_LATITUDE2=48.     # deg (west<0south<0)

# Needed for UTM only, set to 0 if not using UTM
CXR_UTM_ZONE=0

# Needed for POLAR only
CXR_POLAR_LONGITUDE_POLE=0.        # deg (west<0south<0)
CXR_POLAR_LATITUDE_POLE=0.         # deg (west<0south<0)

################################################################################
# Grid definition
################################################################################

# How many grids are used?
CXR_NUMBER_OF_GRIDS=3

# Of course, more grids mean more settings down here

#Master grid (Floats)
CXR_MASTER_ORIGIN_XCOORD=-1282.5       # km or deg SW corner of cell(1,1)
CXR_MASTER_ORIGIN_YCOORD=-1066.5       # km or deg SW corner of cell(1,1)

# Floats
CXR_MASTER_CELL_XSIZE=27.               # km or deg
CXR_MASTER_CELL_YSIZE=27.               # km or deg


CXR_MASTER_GRID_COLUMNS=95
CXR_MASTER_GRID_ROWS=79

CXR_NUMBER_OF_LAYERS[1]=14

# Grid 0 and 1 are dummies (except CXR_NUMBER_OF_LAYERS[1])
CXR_NEST_MESHING_FACTOR[0]=-
CXR_NEST_BEG_I_INDEX[0]=-
CXR_NEST_END_I_INDEX[0]=-
CXR_NEST_BEG_J_INDEX[0]=-
CXR_NEST_END_J_INDEX[0]=-
CXR_NUMBER_OF_LAYERS[0]=-

# This is a dummy because entries 1 are given by the MASTER settings
CXR_NEST_MESHING_FACTOR[1]=-
CXR_NEST_BEG_I_INDEX[1]=-
CXR_NEST_END_I_INDEX[1]=-
CXR_NEST_BEG_J_INDEX[1]=-
CXR_NEST_END_J_INDEX[1]=-

# Number of layers set above

# Second grid
CXR_NEST_MESHING_FACTOR[2]=3        # Relative to master grid
CXR_NEST_BEG_I_INDEX[2]=51          # Relative to master grid
CXR_NEST_END_I_INDEX[2]=74          # Relative to master grid
CXR_NEST_BEG_J_INDEX[2]=32          # Relative to master grid
CXR_NEST_END_J_INDEX[2]=49          # Relative to master grid
CXR_NUMBER_OF_LAYERS[2]=14
	
# Third grid
CXR_NEST_MESHING_FACTOR[3]=9        # Relative to master grid
CXR_NEST_BEG_I_INDEX[3]=55          # Relative to master grid
CXR_NEST_END_I_INDEX[3]=68          # Relative to master grid
CXR_NEST_BEG_J_INDEX[3]=35          # Relative to master grid
CXR_NEST_END_J_INDEX[3]=44          # Relative to master grid
CXR_NUMBER_OF_LAYERS[3]=14

################################################################################
# Options for the export of station-specific data
################################################################################

# Which species should be extracted (all does all, otherwise, provide a space separated list)
CXR_STATION_SPECIES=all

# Format can be either CSV or IDL
CXR_STATION_FILE_FORMAT=IDL

# The format of the numbers to use
CXR_STATION_NUMBER_FORMAT=(5e14.7)

# when true, concentrations will be normalized
CXR_STATION_NORMALIZE_CONCENTRATIONS=true

# Using these values for normalization
CXR_STATION_NORMALIZE_TEMPERATURE_K=293
CXR_STATION_NORMALIZE_PRESSURE_PA=101300

# When true, coordinates are logitude/latitude, when false coordinates are grid-indices (0-based)
CXR_STATION_LATLON_COORDINATES=false


# extracting from this grid (currently, only one is supported)
CXR_STATION_DOMAIN=3

################################################################################
# Notification options
################################################################################
CXR_MAILADDR=CAMxRunner@psi.ch
CXR_SMSNR=0765888275
CXR_SMSPROVIDER=sms.switch.ch
CXR_SMSADDR=${CXR_SMSNR}@${CXR_SMSPROVIDER}

# Note that you can configure the log-level 
# CXR_LOG_LEVEL_EXTERNAL
# to decide what to see there.
# As a minimum, you get a mesage when the run starts and when the run ends.

# If this Variable is true,Email will be sent
CXR_SEND_EMAIL=true

#If this Variable is true, SMS will be sent
CXR_SEND_SMS=false

# If this Variable is true, twitter wil be used
# Twitter allows us to publish our logs to a whole group of people
# To use it, create a ~/.twitterrc file (readable only to you)
# that sets the variables ACCOUNT and PASS
CXR_SEND_TWITTER=false

# This string can be formatted as needed.
# I use it to create a row for a table in our Wiki.
# It will be output at the end of the log (expanded)
#
# Make sure, control sequences like \n are double-escaped (\\n)
# because the expansion otherwise removes the sequence.

CXR_FINISH_MESSAGE_RULE='Please copy this into https://wiki.intranet.psi.ch/twiki/LAC/CAMxRuns \\n \| $(date +"%Y/%m/%d") \| ${USER} \| ${CXR_STATUS} \| ${CXR_RUN} \| ${CXR_START_DATE} \| ${CXR_STOP_DATE} \| ${CXR_BASE_DIR} \| http://people.web.psi.ch/oderbolz/CAMx/conf/$(basename "$CXR_CONFIG") \| http://people.web.psi.ch/oderbolz/CAMx/log/$(basename "$CXR_LOG") \| \\n'

################################################################################
# Model options (Solver etc.)
################################################################################
CXR_DIAGNOSTIC_ERROR_CHECK=false    # True=will stop before 1st timestep
CXR_ADVECTION_SOLVER=PPM      # (PPM,BOTT)
CXR_CHEMISTRY_SOLVER=CMC      # (CMC,IEH,LSODE)

# If you use a probing tool other that None, check out the probing section at the end
# of this file (commented out per default)
CXR_PROBING_TOOL=None     # (None,OSAT,PSAT,GOAT,APCA,DDM,PA,RTRAC)
CXR_CHEMISTRY=true
CXR_DRY_DEPOSITION=true
CXR_WET_DEPOSITION=true
CXR_STAGGERED_WINDS=true
CXR_GRIDDED_EMISSIONS=true
CXR_POINT_EMISSIONS=false
CXR_IGNORE_EMISSION_DATES=true

# Generate PIG relevant code
CXR_PLUME_IN_GRID=false
CXR_PIG_SUBMODEL=None     # (None,GREASD,IRON)


################################################################################
# Chemical and aerosol Mechanism
################################################################################

# Here choose between these possibilities (taken from the CAMx Guide)
# 3 (Carbon Bond IV - Gery et al. 1989)
# 1 (same as above, but with reactive chlorine chemistry - Tanaka et al., 2000)
# 4 (Carbon Bond IV - CB4)
# 5 (SAPRC99, Carter, 2000)
# 6 (Carbon Bond version 2005 - CB05) - Default for CAMx 4.51
# 10 (User defined)

CXR_CHEMICAL_MECHANISM=6

# Choose between 
# CF for (Coarse fine) 
# CF+hg (Coarse fine with mercury)
# CMU (Carnegie Mellon sectional model) 
# NONE (No Aerosols)
# Aerosol Chemistry is currently only supported with mechanisms 4 and 6 - CAMxRunner will complain but try anyway
CXR_AEROSOL_MECHANISM=CF

# The CAMxRunner determines the name of the chemparam file automatically
# but you can overwrite this behavior by setting this parameter
# In this case it uses your setting
# CXR_CHEMPARAM_INPUT_FILE=


################################################################################
# Labels used for filenames
################################################################################
CXR_MET_PROJECT=uw3
CXR_MET_SCENARIO=s151

# Either WRF or MM5
CXR_MET_MODEL=MM5

# Versionof the meteo model (not used for MM5)
CXR_MET_VERSION=

CXR_EMMISS_PROJECT=${CXR_MET_PROJECT}
CXR_EMMISS_SCENARIO=sem050

CXR_CAMX_SCENARIO=${CXR_MET_SCENARIO}
CXR_CAMX_CUSTOMER=bafu3

CXR_STATION_LABEL=NABEL

################################################################################
# Directories 
# Attention: Put no variables in directory names that are not yet set here!
# E. g. any variable containing dates (like simulation year) will fail to expand!
################################################################################

CXR_BASE_DIR=/afs/psi.ch/intranet/LAC/oderbolz/CAMxRuns/Runs/${CXR_RUN}
CXR_INPUT_DIR=${CXR_BASE_DIR}/Inputs

# Set Meteodir according to Model
case $CXR_MET_MODEL in

	MM5)
			CXR_METEO_DIR=/afs/psi.ch/intranet/LAC/keller_j/linuxmm5/out
			CXR_MET_PREFIX=camx
			;;
	WRF)
			CXR_METEO_DIR=/afs/psi.ch/intranet/LAC/keller_j/linuxwrf/out_${CXR_MET_VERSION}
			CXR_MET_PREFIX=camxw
			;;

esac

CXR_LANDUSE_DIR=/afs/psi.ch/intranet/LAC/keller_j/linuxmm5/out/const

# Directory where to find MOZART global data
CXR_GLOBAL_CTM_DIR=/afs/psi.ch/intranet/LAC/oderbolz/CAMxRuns/MOZART

CXR_EMISSION_DIR=${CXR_BASE_DIR}/Emiss
CXR_PTSRCE_DIR=${CXR_BASE_DIR}/Ptsrce

# Input preparation directories
CXR_EMISSION_SOURCE_DIR=/afs/psi.ch/intranet/LAC/keller_j/emiss/emisscamx

# This is the main output directory
CXR_OUTPUT_DIR=${CXR_BASE_DIR}/Outputs

# Probing output dirs
CXR_PA_OUTPUT_DIR=${CXR_OUTPUT_DIR}/PA
CXR_DDM_OUTPUT_DIR=${CXR_OUTPUT_DIR}/DDM
CXR_RT_OUTPUT_DIR=${CXR_OUTPUT_DIR}/RT
CXR_SA_OUTPUT_DIR=${CXR_OUTPUT_DIR}/SA

CXR_ASCII_OUTPUT_DIR=${CXR_OUTPUT_DIR}/ascii
CXR_STATION_OUTPUT_DIR=${CXR_OUTPUT_DIR}/Nabel
CXR_DIRECT_OUTPUT_DIR=~/@direct

################################################################################
# Rules for filenames (See http://people.web.psi.ch/oderbolz/CAMxRunner#FileRules)
#
# There are more filerules in the Probing sections of this file
#
# These ABSOLUTELY need 'single quotes' around them, otherwise the shell expands them here!
################################################################################

################## Grid independent ############################################

# Input Preparation ############################################################


# Input ########################################################################

# The meteo files might have a different name on startup
CXR_DAY_METEO_FIRST_DAY_RULE='${CXR_DAY}_s'

CXR_PHOTOLYIS_RATES_FILE_RULE='${CXR_INPUT_DIR}/tuv_${CXR_CAMX_CUSTOMER}_${CXR_YEAR_S}_${CXR_WOY}.out'
CXR_INITIAL_CONDITIONS_FILE_RULE='${CXR_INPUT_DIR}/ic_${CXR_CAMX_CUSTOMER}_moz.bin'
CXR_BOUNDARY_CONDITIONS_FILE_RULE='${CXR_INPUT_DIR}/bc_${CXR_CAMX_CUSTOMER}_moz_${CXR_YEAR_S}${CXR_MONTH}${CXR_DAY}.bin'
CXR_TOP_CONCENTRATIONS_FILE_RULE='${CXR_INPUT_DIR}/topconc_${CXR_CAMX_CUSTOMER}${CXR_YEAR_S}.${CXR_ASC_EXT}'
CXR_ALBEDO_HAZE_OZONE_FILE_RULE='${CXR_INPUT_DIR}/ahomap_${CXR_CAMX_CUSTOMER}_3grids_${CXR_YEAR_S}_${CXR_WOY}.out'

CXR_POINT_SOURCES_FILE_RULE=''

# These are needed as input (last day)
CXR_MASTER_GRID_RESTART_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW_YESTERDAY}.inst'
CXR_NESTED_GRID_RESTART_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW_YESTERDAY}.finst'
# These are needed as output (this day)
CXR_MASTER_GRID_RESTART_OUT_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW}.inst'
CXR_NESTED_GRID_RESTARTT_OUT_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW}.finst'

# More restart rules in the probing sections later

CXR_PIG_RESTART_FILE_RULE=''

CXR_ROOT_OUTPUT_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW}'

# File Roots for probing
CXR_PA_ROOT_OUTPUT_FILE_RULE='$CXR_PA_OUTPUT_DIR/${CXR_RUN}.${CXR_YEAR_S}${CXR_MONTH}${CXR_DAY}'

CXR_DDM_ROOT_OUTPUT_FILE_RULE='$CXR_DDM_OUTPUT_DIR/${CXR_RUN}.${CXR_YEAR_S}${CXR_MONTH}${CXR_DAY}'
CXR_RT_ROOT_OUTPUT_FILE_RULE='$CXR_RT_OUTPUT_DIR/${CXR_RUN}.${CXR_YEAR_S}${CXR_MONTH}${CXR_DAY}'
CXR_SA_ROOT_OUTPUT_FILE_RULE='$CXR_SA_OUTPUT_DIR/${CXR_RUN}.${CXR_YEAR_S}${CXR_MONTH}${CXR_DAY}'

# These are used 
#	* to prevent overwriting of existing files 
#	* the creation of the aqmfad directory
#	* to convert the binary output files
#	These are dependent on another rule - check the quoting!
CXR_DIAG_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.diag'
CXR_FINST_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.finst'
CXR_INST_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.inst'
CXR_MASS_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.mass'
CXR_OUT_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.out'

################## NABEL (Station dependent)#####################################

# The local variable $station will be replaced by the actual name of the station in question
CXR_STATION_FILE_RULE='${CXR_STATION_OUTPUT_DIR}/${CXR_RUN}.${CXR_YEAR_S}${CXR_MONTH}${CXR_DAY}_domain${CXR_IGRID}_${station}.dat'

# This is the name of the cumulated file
CXR_CUMULATIVE_STATION_FILE_RULE='${CXR_STATION_OUTPUT_DIR}/${CXR_RUN}.${CXR_YEAR_S}${CXR_MONTH}_${station}-complete.dat'

################## Grid spcecific ##############################################

# These NEED the variable ${CXR_IGRID} somewhere (the grid number)

# Input Preparation ############################################################

# Emission (classical)
CXR_EMISSION_ASC_FILE_RULE='${CXR_EMISSION_SOURCE_DIR}/${CXR_DATE_RAW}/${CXR_EMMISS_SCENARIO}/camx_emiss_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_EMMISS_SCENARIO}_${CXR_DATE_RAW}.asc'
CXR_EMISSION_BIN_FILE_RULE='${CXR_EMISSION_DIR}/camx_emiss_domain${CXR_IGRID}_${CXR_EMMISS_PROJECT}_${CXR_EMMISS_SCENARIO}_${CXR_DATE_RAW}.bin'


# Input ########################################################################

# This one is needed for initial and bounary conditions
CXR_MMOUT_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/mmout_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'

#Landuse
CXR_LANDUSE_FILE_RULE='${CXR_INPUT_DIR}/terrain_domain${CXR_IGRID}_${CXR_MET_PROJECT}_lucamx.bin'

# Pressure
CXR_PRESSURE_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/${CXR_MET_PREFIX}_zp_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'

# Wind
CXR_WIND_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/${CXR_MET_PREFIX}_uv_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'

# Temperature
CXR_TEMPERATURE_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/${CXR_MET_PREFIX}_tp_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'

# Vapor
CXR_VAPOR_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/${CXR_MET_PREFIX}_qa_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'

# Cloud
CXR_CLOUD_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/${CXR_MET_PREFIX}_cr_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'

# Vertical K
CXR_K_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/${CXR_MET_PREFIX}_kv_CMAQ_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'
 
# Emissions
CXR_EMISSION_FILE_RULE=${CXR_EMISSION_BIN_FILE_RULE}

# Output #######################################################################

#Deposition file (dependency -> quoting!)
CXR_DEPN_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.depn.grd0${CXR_IGRID}'

# The actual average file (THE OUTPUT) (dependency -> quoting!)
CXR_AVG_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.avrg.grd0${CXR_IGRID}'  

# We create the ASCII version of thefiles in the aqmfad directory      
# All rules start with the CXR_ASCII_OUTPUT_DIR and end with ${CXR_ASC_EXT}
CXR_AVG_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW}.avrg.grd0${CXR_IGRID}.${CXR_ASC_EXT}'

# Landuse ASCII File is provided by MM5, we will convert it to binary
CXR_LANDUSE_ASC_FILE_RULE='${CXR_LANDUSE_DIR}/terrain_domain${CXR_IGRID}_${CXR_MET_PROJECT}_lucamx.asce'

# Terrain elevation for aqmfad
CXR_TERRAIN_ASC_FILE_RULE='${CXR_LANDUSE_DIR}/terrain_domain${CXR_IGRID}_${CXR_MET_PROJECT}_terrcamx.asce'

CXR_PRESSURE_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_MET_PREFIX}_zp_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}.${CXR_ASC_EXT}'
CXR_WIND_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_MET_PREFIX}_uv_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}.${CXR_ASC_EXT}'
CXR_TEMPERATURE_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_MET_PREFIX}_tp_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}.${CXR_ASC_EXT}'
CXR_VAPOR_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_MET_PREFIX}_qa_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}.${CXR_ASC_EXT}'
CXR_CLOUD_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_MET_PREFIX}_cr_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}.${CXR_ASC_EXT}'
CXR_K_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_MET_PREFIX}_kv_CMAQ_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}.${CXR_ASC_EXT}'		

################################################################################
# Preprocessors
################################################################################	

########################################
# albedo_haze_ozone (AHOMAP)
########################################

# Rules to generate the URL to get the ozone column (works from October 2004 on)
CXR_AHOMAP_OZONE_COLUMN_FILE_RULE='L3_ozone_omi_${CXR_DATE_RAW}.txt'
# Nesting of rule - attention with the quoting
CXR_AHOMAP_OZONE_COLUMN_URL_RULE='ftp://toms.gsfc.nasa.gov/pub/omi/data/ozone/Y${CXR_YEAR}/'${CXR_AHOMAP_OZONE_COLUMN_FILE_RULE}

# For data earlier than October 2004
#CXR_AHOMAP_OZONE_COLUMN_FILE_RULE='L3_ozone_epc_${CXR_DATE_RAW}.txt'

# Nesting of rule - attention with the quoting
#CXR_AHOMAP_OZONE_COLUMN_URL_RULE='ftp://toms.gsfc.nasa.gov/pub/eptoms/data/ozone/Y${CXR_YEAR}/'${CXR_AHOMAP_OZONE_COLUMN_FILE_RULE}


# This is where the files go
CXR_AHOMAP_OZONE_COLUMN_DIR=${CXR_PREPROCESSOR_ONCE_INPUT_DIR}/albedo_haze_ozone/ozone_column

# Should AHOMAP consider snow (boolean)
CXR_AHOMAP_SNOW=false

# How often do we run AHOMAP and TUV?
# currently supported: once, daily,monthly, weekly
# if not set, once is assumed.
# In the case of daily, weekly or monthly, 
# The filerules CXR_PHOTOLYIS_RATES_FILE_RULE and CXR_ALBEDO_HAZE_OZONE_FILE_RULE
# need to contain CXR_DATE, CXR_WOY or CXR_MONTH, respectively (we need a unique filename!)
CXR_RUN_AHOMAP_TUV_INTERVAL=weekly

########################################
# photolysis_rates (TUV)
########################################

# Choose between these 2:
# 1 : pseudo-spherical two-stream delta-Eddington (ps2str.f) - fast
# 2 : discrete ordinates method (slower but more accurate)
CXR_TUV_RADIATIVE_TRANSFER_SCHEME=2

# This is a list of reaction numbers that need Photolysis rates 
# This depends on the chemistry parameters file!
# We try to make the correct guess here :-)

case "${CXR_CHEMICAL_MECHANISM}" in
		
			1 | 3 | 4 )
				# take this for CB4 with updated isoprene chemistry (CAMx mechanisms 1, 3 and 4)
				CXR_TUV_REACTION_NUMBERS="4, 15, 16, 2, 17, 56"
				;;
				
			5)
				# take this for SAPRC99 (Mechanism 5)
				CXR_TUV_REACTION_NUMBERS="100, 91, 90, 103, 85, 105"
				;;
			
			6)

				# Take this for CBM05 (Mechanism 6)
				CXR_TUV_REACTION_NUMBERS="100, 122, 121, 102, 101, 125, 89, 126, 127, 128, 129, 86, 91, 90, 85, 130, 84, 131, 70"
				;;
				
			*)	main.dieGracefully "The chemical mechanism ${CXR_CHEMICAL_MECHANISM} is not supported by this configuration file"
				;;

esac

CXR_TUV_NO_OF_REACTIONS=$(main.countDelimitedElements "$CXR_TUV_REACTION_NUMBERS" ",")

# This is stuff that we need to configure the CAMx compilation (camx.prm) and
# TUV operation. (TUV layer definition to calculate look-up table)
CXR_NOZN=5
CXR_NALB=5
CXR_NHAZ=3
CXR_NRUF=9
CXR_NHGHT=11
CXR_NZEN=10
CXR_NLU=11

# Now we need to indicate a height above ground for each of the CXR_NHGHT levels
CXR_TUV_HEIGHTS="0. 0.15 0.35 0.60 1.00 2.00 3.00 4.00 6.00 8.00 10.0"


########################################
# Preparation of IC/BC/TC
########################################

# Method that is used to determine ic/bc/tc
# Currently supported: MOZART, MOZART_INCREMENT, MOZART_CONSTANT or ICBCPREP
#
# MOZART uses the data from the MOZART global CTM
# MOZART_CONSTANT uses our preprocessor but replaces some of the MOZART data by constant values
# MOZART_INCREMENT allows to selectively increment certain species by a specified value (in PPM)
# ICBCPREP uses the ENVIRON preprocessor icbcprep (resulting in constant IC and BC data)

CXR_IC_BC_TC_METHOD=MOZART_CONSTANT

# Setup MOZART species, if needed
if [[ ${CXR_IC_BC_TC_METHOD:0:6} == MOZART ]]
then
	# This array describes the mapping of MOZART to CAMx species
	# Prior to 2004, MOZART provides only 5 species
	# The order is the same, so it is sufficient to change this parameter
	# in the config file
	
	# Unset first - it's an array!
	unset CXR_CAMX_MOZART_MAPPING
	
	# Syntax is CAMx:MOZART
	CXR_CAMX_MOZART_MAPPING[0]=O3:O3_VMR_inst
	CXR_CAMX_MOZART_MAPPING[1]=CO:CO_VMR_inst
	CXR_CAMX_MOZART_MAPPING[2]=FORM:CH2O_VMR_inst
	CXR_CAMX_MOZART_MAPPING[3]=NO:NO_VMR_inst
	CXR_CAMX_MOZART_MAPPING[4]=NO2:NO2_VMR_inst
	CXR_CAMX_MOZART_MAPPING[5]=HNO3:HNO3_VMR_inst
	CXR_CAMX_MOZART_MAPPING[6]=PNA:HO2NO2_VMR_inst
	CXR_CAMX_MOZART_MAPPING[7]=H2O2:H2O2_VMR_inst
	CXR_CAMX_MOZART_MAPPING[8]=PAN:PAN_VMR_inst
	CXR_CAMX_MOZART_MAPPING[9]=CH4:CH4_VMR_inst
	CXR_CAMX_MOZART_MAPPING[10]=ALD2:CH3CHO_VMR_inst
	CXR_CAMX_MOZART_MAPPING[11]=ETHA:C2H6_VMR_inst
	CXR_CAMX_MOZART_MAPPING[12]=ISOP:ISOP_VMR_inst
	CXR_CAMX_MOZART_MAPPING[13]=ISP:ISOP_VMR_inst
	CXR_CAMX_MOZART_MAPPING[14]=TOL:TOLUENE_VMR_inst
	CXR_CAMX_MOZART_MAPPING[15]=TOLA:TOLUENE_VMR_inst
	
	# Automatically count # species (no dummy)
	CXR_NUMBER_OF_GCTM_SPECIES=$(( ${#CXR_CAMX_MOZART_MAPPING[@]} ))
fi

if [[ "$CXR_IC_BC_TC_METHOD" != MOZART ]]
then
	# If we are not using MOZART, we need to define the constant values
	# or the increments.
	# If you are using MOZART_CONSTANT, you need to supply data for each element
	# of CXR_CAMX_MOZART_MAPPING because the preprocessors loops through that array

	# Here you need to define the species and the concentrations
	# (in ppm for gases, in ug/m**3 for aerosols) to use (format is "SPECIES:conc")
	# Depending on CXR_IC_BC_TC_METHOD, these are either increments or constant values.
	# Make sure the numbers are in Fortran 10.7 Format
	
	# Unset first - it's an array!
	unset CXR_IC_BC_TC_SPEC
	
	CXR_IC_BC_TC_SPEC[0]=O3:0.05
	CXR_IC_BC_TC_SPEC[1]=CO:0.20
	CXR_IC_BC_TC_SPEC[2]=FORM:0.0014
	CXR_IC_BC_TC_SPEC[3]=NO:0.0005
	CXR_IC_BC_TC_SPEC[4]=NO2:0.005
	CXR_IC_BC_TC_SPEC[5]=HNO3:0.001
	CXR_IC_BC_TC_SPEC[6]=PNA:0.000001336 
	CXR_IC_BC_TC_SPEC[7]=H2O2:0.001014395 
	CXR_IC_BC_TC_SPEC[8]=PAN:0.000176876 
	CXR_IC_BC_TC_SPEC[9]=CH4:1.843935728 
	CXR_IC_BC_TC_SPEC[10]=ALD2:0.000023972 
	CXR_IC_BC_TC_SPEC[11]=ETHA:0.000482804 
	CXR_IC_BC_TC_SPEC[12]=ISOP:0.000002357 
	CXR_IC_BC_TC_SPEC[13]=TOL:0.000009159 
	
fi



########################################
# initial_conditions
########################################

# Where to find the MOZART files
CXR_GLOBAL_CTM_FILE_RULE='$CXR_GLOBAL_CTM_DIR/h${CXR_YEAR}${CXR_MONTH}${CXR_DAY}00.nc'

# This is the IDL procedure for the initial_conditions generation
CXR_IC_PROC_INPUT_FILE=${CXR_PREPROCESSOR_ONCE_INPUT_DIR}/initial_conditions/camxinit.pro

########################################
# boundary_conditions
########################################

# This is the IDL procedure for the boundary_conditions generation
CXR_BC_PROC_INPUT_FILE=${CXR_PREPROCESSOR_DAILY_INPUT_DIR}/boundary_conditions/camxbound.pro

########################################
# split Emissions (PMCAMx 2008 only)
########################################

CXR_SPLIT_EMISSIONS_INPUT_FILE_RULE=''
CXR_SPLIT_EMISSIONS_OUTPUT_FILE_RULE=''

########################################
# create emissions
########################################

# must be either "koeble", "more_trees" or "classical"
CXR_EMISSION_BIO_APPROACH=classical

# set to 1 if you want to generate OVOC
CXR_EMISSION_DO_OVOC=0

################################################################################
# Postprocessors
################################################################################


########################################
# AVGDIF - we compare our output 
########################################

# Where do we find the inputs to compare to?
CXR_REFERENCE_FILE_RULE='/afs/psi.ch/intranet/LAC/oderbolz/CAMxRuns/Runs/CAMx-v4.51-bafu3-june-2006-s147-sem045-dummy/Outputs/CAMx-v4.51-bafu3-june-2006-s147-sem045-dummy.${CXR_DATE_RAW}.avrg.grd0${CXR_IGRID}'

# Where do we put the output file?
CXR_AVGDIF_OUTPUT_FILE_RULE='$CXR_LOG_OUTPUT_DIR/$CXR_RUN-avgdif_report-${CXR_DATE_RAW}.avrg.grd0${CXR_IGRID}.log'

# Define min and may layers to compare (to save time, leave both on 1)
CXR_AVGDIF_MIN_LAYER=1
CXR_AVGDIF_MAX_LAYER=1

########################################
# extract_station_data
########################################	

# This is the IDL procedure for the extraction
# Because it is not executable, we treat it as an input file
CXR_STATION_PROC_INPUT_FILE=${CXR_POSTPROCESSOR_DAILY_INPUT_DIR}/extract_station_data/extract_nabel_stations.pro

# Station coordinates can be expressed in any projection
# supported by <common.map.LonLatToProjection>. 
CXR_STATION_PROJECTION="SWISS"

# Which grid(s) do we extract on
# make sure your CXR_STATION_FILE_RULE supports CXR_IGRID if you have more than one station here.
CXR_RUN_EXTRACTION_ON_GRID="3"

########################################
# aqmfad/emifad
########################################

# Aqmfad options
# This is treated like an array
#CXR_RUN_AQMFAD_ON_GRID="1 2 3"
CXR_RUN_AQMFAD_ON_GRID="3"

# the same for emifad
CXR_RUN_EMIFAD_ON_GRID="1 3"

################################################################################
# CAMxRunner specific settings
################################################################################

################################################################################
# If you want to disable modules of the CAMxRunner, do it here
################################################################################

# Set this to false to disable CAMx in this run
CXR_RUN_MODEL=true

# This string contains the space-separated  module names of
# unwanted one-time preprocessors.
# If "${CXR_SKIP_ALL}" is given, all one-time preprocessors are skipped
CXR_DISABLED_ONCE_PREPROC=""

# This string contains the space-separated module names of
# unwanted daily preprocessors like "create_emissions"
# If "${CXR_SKIP_ALL}" is given, all daily preprocessors are skipped
CXR_DISABLED_DAILY_PREPROC="create_emissions"

# This string contains the space-separated module names of
# unwanted daily postprocessors
# If "${CXR_SKIP_ALL}" is given, all daily postprocessors are skipped
CXR_DISABLED_DAILY_POSTPROC="avgdif"

# This string contains the space-separated module names of
# unwanted one-time postprocessors.
# If "${CXR_SKIP_ALL}" is given, all one-time postprocessors are skipped
export  CXR_DISABLED_ONCE_POSTPROC=""

# This string contains the space-separated module names of
# unwanted model scripts.
# If "${CXR_SKIP_ALL}" is given, all one-time postprocessors are skipped
export  CXR_DISABLED_MODEL=""

# This string contains the space-separated module names of
# unwanted installers.
# If "${CXR_SKIP_ALL}" is given, all installers are skipped
export  CXR_DISABLED_INSTALLER=""


################################################################################
# Enabled overrules disabled. If you add a module here, it will be executed,
# even if it was disabled before.
# In contrast to above there is no catch all setting (like enable_all). 
# The idea is that you can disable a whole class above, but activate single
# modules of this class here easily without having to enumerate all that you 
# do not want.
################################################################################

# This string contains the space-separated  module names of
# wanted one-time preprocessors.
CXR_ENABLED_ONCE_PREPROC=""

# This string contains the space-separated module names of
# wanted daily preprocessors like "create_emissions"
CXR_ENABLED_DAILY_PREPROC=""

# This string contains the space-separated module names of
# wanted daily postprocessors
CXR_ENABLED_DAILY_POSTPROC=""

# This string contains the space-separated module names of
# wanted one-time postprocessors.
export  CXR_ENABLED_ONCE_POSTPROC=""

# This string contains the space-separated module names of
# wanted model scripts.
export  CXR_ENABLED_MODEL=""

# This string contains the space-separated module names of
# wanted installers.
export  CXR_ENABLED_INSTALLER=""

########################################
# Parallel Task execution
########################################

# Do we run processing parallel?
# This means that we use a number of backgroung processes
# to process all tasks an a way that respects the dependencies
# Can speed up things significantly.
CXR_PARALLEL_PROCESSING=false

# The number of processes is set later in the parallel (OMP) section

################################################################################
################################################################################
# Changes below this Comment are rather unusual
################################################################################
################################################################################

################################################################################
# Output specifications
################################################################################

# Consider to set this to false if space is scarce - you will only get the lowest model layer
# However, this means that some postprocessors need to bo called differently (so that they do not loop over n layers)
CXR_AVERAGE_OUTPUT_3D=true
CXR_HDF_FORMAT_OUTPUT=false

################################################################################
# Chemical species
################################################################################

# First unset array
unset CXR_OUTPUT_SPECIES_NAMES

# Selection of output species
case "${CXR_AEROSOL_MECHANISM}" in

	CF)

		case "${CXR_CHEMICAL_MECHANISM}" in
		
			4)
				# CF-CBIV (as used before, extended by inert aerosol species at the end)
				# Entry 0 is a dummy, we want our arrays to start with index 1
				CXR_OUTPUT_SPECIES_NAMES[0]=-
				CXR_OUTPUT_SPECIES_NAMES[1]=NO
				CXR_OUTPUT_SPECIES_NAMES[2]=NO2
				CXR_OUTPUT_SPECIES_NAMES[3]=O3
				CXR_OUTPUT_SPECIES_NAMES[4]=TOL
				CXR_OUTPUT_SPECIES_NAMES[5]=XYL
				CXR_OUTPUT_SPECIES_NAMES[6]=FORM
				CXR_OUTPUT_SPECIES_NAMES[7]=PAN
				CXR_OUTPUT_SPECIES_NAMES[8]=CO
				CXR_OUTPUT_SPECIES_NAMES[9]=HONO
				CXR_OUTPUT_SPECIES_NAMES[10]=HNO3
				CXR_OUTPUT_SPECIES_NAMES[11]=H2O2
				CXR_OUTPUT_SPECIES_NAMES[12]=ISOP
				CXR_OUTPUT_SPECIES_NAMES[13]=PNA
				CXR_OUTPUT_SPECIES_NAMES[14]=SO2
				CXR_OUTPUT_SPECIES_NAMES[15]=NH3
				CXR_OUTPUT_SPECIES_NAMES[16]=PH2O
				CXR_OUTPUT_SPECIES_NAMES[17]=PNO3
				CXR_OUTPUT_SPECIES_NAMES[18]=PSO4
				CXR_OUTPUT_SPECIES_NAMES[19]=PNH4
				CXR_OUTPUT_SPECIES_NAMES[20]=POA
				CXR_OUTPUT_SPECIES_NAMES[21]=PEC
				CXR_OUTPUT_SPECIES_NAMES[22]=SOA1
				CXR_OUTPUT_SPECIES_NAMES[23]=SOA2
				CXR_OUTPUT_SPECIES_NAMES[24]=SOA3
				CXR_OUTPUT_SPECIES_NAMES[25]=SOA4
				CXR_OUTPUT_SPECIES_NAMES[26]=SOA5
				CXR_OUTPUT_SPECIES_NAMES[27]=NA
				CXR_OUTPUT_SPECIES_NAMES[28]=PCL
				CXR_OUTPUT_SPECIES_NAMES[29]=FPRM
				CXR_OUTPUT_SPECIES_NAMES[30]=FCRS
				CXR_OUTPUT_SPECIES_NAMES[31]=CPRM
				CXR_OUTPUT_SPECIES_NAMES[32]=CCRS
				;;
		
			6)
				# CF-CB05
				# Entry 0 is a dummy, we want our arrays to start with index 1
				CXR_OUTPUT_SPECIES_NAMES[0]=-
				CXR_OUTPUT_SPECIES_NAMES[1]=NO
				CXR_OUTPUT_SPECIES_NAMES[2]=NO2
				CXR_OUTPUT_SPECIES_NAMES[3]=O3
				CXR_OUTPUT_SPECIES_NAMES[4]=TOL
				CXR_OUTPUT_SPECIES_NAMES[5]=XYL
				CXR_OUTPUT_SPECIES_NAMES[6]=FORM
				CXR_OUTPUT_SPECIES_NAMES[7]=PAN
				CXR_OUTPUT_SPECIES_NAMES[8]=CO
				CXR_OUTPUT_SPECIES_NAMES[9]=HONO
				CXR_OUTPUT_SPECIES_NAMES[10]=HNO3
				CXR_OUTPUT_SPECIES_NAMES[11]=H2O2
				CXR_OUTPUT_SPECIES_NAMES[12]=ISOP
				CXR_OUTPUT_SPECIES_NAMES[13]=PNA
				CXR_OUTPUT_SPECIES_NAMES[14]=SO2
				CXR_OUTPUT_SPECIES_NAMES[15]=NH3
				CXR_OUTPUT_SPECIES_NAMES[16]=PH2O
				CXR_OUTPUT_SPECIES_NAMES[17]=PNO3
				CXR_OUTPUT_SPECIES_NAMES[18]=PSO4
				CXR_OUTPUT_SPECIES_NAMES[19]=PNH4
				CXR_OUTPUT_SPECIES_NAMES[20]=POA
				CXR_OUTPUT_SPECIES_NAMES[21]=PEC
				CXR_OUTPUT_SPECIES_NAMES[22]=SOA1
				CXR_OUTPUT_SPECIES_NAMES[23]=SOA2
				CXR_OUTPUT_SPECIES_NAMES[24]=SOA3
				CXR_OUTPUT_SPECIES_NAMES[25]=SOA4
				CXR_OUTPUT_SPECIES_NAMES[26]=SOA5
				CXR_OUTPUT_SPECIES_NAMES[27]=SOA6
				CXR_OUTPUT_SPECIES_NAMES[28]=SOA7
				CXR_OUTPUT_SPECIES_NAMES[29]=SOPA
				CXR_OUTPUT_SPECIES_NAMES[30]=SOPB
				CXR_OUTPUT_SPECIES_NAMES[31]=NA
				CXR_OUTPUT_SPECIES_NAMES[32]=PCL
				CXR_OUTPUT_SPECIES_NAMES[33]=FPRM
				CXR_OUTPUT_SPECIES_NAMES[34]=FCRS
				CXR_OUTPUT_SPECIES_NAMES[35]=CPRM
				CXR_OUTPUT_SPECIES_NAMES[36]=CCRS
				;;
			
			*)	main.dieGracefully "The chemical mechanism ${CXR_CHEMICAL_MECHANISM} is not supported by this configuration file"
				;;
			
		esac # Chemical Mechanism
		;;
		
	*) main.dieGracefully "The aerosol mechanism ${CXR_AEROSOL_MECHANISM} is not supported by this configuration file!"
	   ;;
		
		
esac # Aerosol Mechanism

# Automatically count # species (subtract 1 for dummy)
CXR_NUMBER_OF_OUTPUT_SPECIES=$(( ${#CXR_OUTPUT_SPECIES_NAMES[@]} - 1 ))

################################################################################
# The OPM settings are machine-dependent.
################################################################################ 
# Are we on a multicore system?
CXR_NUMBER_OF_CORES=$(main.countCores)

# Maximal number of parallel processes in the CAMxRunner
if [[ "$CXR_PARALLEL_PROCESSING" == true  ]]
then
	# By default, use the number of cores
	CXR_MAX_PARALLEL_PROCS=$CXR_NUMBER_OF_CORES
else
	# Non-Parallel use 1 process
	CXR_MAX_PARALLEL_PROCS=1
fi

# This can be either None, OMP or MPI (MPI needs CAMx 5.x or higher). OMP is recommended.
# the CAMx executable must provide this!
CXR_PARALLEL_PARADIGM=OMP

################################################################################
# OpenMP settings
################################################################################
# Switch on OMP
# If OMP_NUM_THREADS=1, OMP is turned off

# Set number of OpenMP threads (to be nice, we use only half of the available cores)
export OMP_NUM_THREADS=$(( $CXR_NUMBER_OF_CORES / 2 ))

# Per Thread stack size. Can lead to problems if both to large or too small...
export MPSTKZ=128M

################################################################################
# Determine name of executable.
################################################################################

# If you need another executable name,
# set this value to a full path.
#CXR_MODEL_EXEC=/path/to/my/exec

################################################################################
# Settings for compression/decompression
################################################################################

# Add a decompressor for each filetype we want to decompress
# Needed options must be passed right here!
# The decompressor MUST write to stdout if -c is passed without deleting the input file
common.conf.set "common.decompressor.lzo=$CXR_LZOP_EXEC -d"
common.conf.set "common.decompressor.lzop=$CXR_LZOP_EXEC -d"
common.conf.set "common.decompressor.bz2=$CXR_BUNZIP2_EXEC -d -k"
common.conf.set "common.decompressor.gz=$CXR_GUNZIP_EXEC -d"
common.conf.set "common.decompressor.gzip=$CXR_GUNZIP_EXEC -d"
common.conf.set "common.decompressor.zip=$CXR_GUNZIP_EXEC -d"

# The compressors are chosen depending on the filetype
common.conf.set "common.compressor.default=$CXR_GZIP_EXEC -1"
common.conf.set "common.compressor.ascii=$CXR_LZOP_EXEC -U"
# CAMx output is reported as MPEG
common.conf.set "common.compressor.mpeg=$CXR_GZIP_EXEC -1"
common.conf.set "common.compressor.data=$CXR_GZIP_EXEC -1"

################################################################################
# Probing settings
################################################################################

CXR_SA_RECEPTOR_DEFINITIONS_FILE_RULE='${CXR_INPUT_DIR}/sa.rcp.def.dat'

## Set probing only if needed
#if [[ "$CXR_PROBING_TOOL" == "PA" || "$CXR_PROBING_TOOL" == "IPR" || "$CXR_PROBING_TOOL" == "IRR" || "$CXR_PROBING_TOOL" == "CPA" ]]
#then
#
#	CXR_NUMBER_OF_PA_DOMAINS=2
#	
#	# Entry 0 is a dummy, we want our arrays to start with index 1
#	CXR_WITHIN_CAMX_GRID[0]=-
#	CXR_PA_BEG_I_INDEX[0]=-
#	CXR_PA_END_I_INDEX[0]=-
#	CXR_PA_BEG_J_INDEX[0]=-
#	CXR_PA_END_J_INDEX[0]=-
#	CXR_PA_BEG_K_INDEX[0]=-
#	CXR_PA_END_K_INDEX[0]=-
#	
#	
#	CXR_WITHIN_CAMX_GRID[1]=3  # Specify which CAMx grid that this PA domain is in
#	CXR_PA_BEG_I_INDEX[1]=62
#	CXR_PA_END_I_INDEX[1]=76
#	CXR_PA_BEG_J_INDEX[1]=63
#	CXR_PA_END_J_INDEX[1]=74
#	CXR_PA_BEG_K_INDEX[1]=1
#	CXR_PA_END_K_INDEX[1]=5
#	
#	CXR_WITHIN_CAMX_GRID[2]=3  # Specify which CAMx grid that this PA domain is in
#	CXR_PA_BEG_I_INDEX[2]=75
#	CXR_PA_END_I_INDEX[2]=92
#	CXR_PA_BEG_J_INDEX[2]=14
#	CXR_PA_END_J_INDEX[2]=30
#	CXR_PA_BEG_K_INDEX[2]=1
#	CXR_PA_END_K_INDEX[2]=5
#
# The extractor also needs config data. 
#
#	
#	# PA file rules (Should contain CXR_PA_IGRID)
#	CXR_PA_IPR_OUTPUT_FILE_RULE='$CXR_PA_OUTPUT_DIR/${CXR_RUN}.${CXR_YEAR_S}${CXR_MONTH}${CXR_DAY}.ipr'
#	CXR_PA_IRR_OUTPUT_FILE_RULE='$CXR_PA_OUTPUT_DIR/${CXR_RUN}.${CXR_YEAR_S}${CXR_MONTH}${CXR_DAY}.irr'
#	
#	# CPA data is produced on a per-grid basis (currently not supported)
#	# CXR_PA_CPA_OUTPUT_FILE_RULE='$CXR_PA_OUTPUT_DIR/${CXR_RUN}.${CXR_YEAR_S}${CXR_MONTH}${CXR_DAY}.cpa.grd$(printf "%02d" ${CXR_IGRID})'
#
#	
#	# Output of the postprocessors
#	CXR_PA_IPR_EXT_OUTPUT_FILE_RULE='$CXR_PA_OUTPUT_DIR/${CXR_RUN}_ext_ipr_PA_${CXR_PA_IGRID}.asc'
#	CXR_PA_IRR_EXT_ASC_OUTPUT_FILE_RULE='$CXR_PA_OUTPUT_DIR/${CXR_RUN}_ext_irr_PA_${CXR_PA_IGRID}.asc'
#	CXR_PA_IRR_EXT_BIN_OUTPUT_FILE_RULE='$CXR_PA_OUTPUT_DIR/${CXR_RUN}_ext_irr_PA_${CXR_PA_IGRID}.bin'
#	
#	
#	CXR_PA_EXT_UNITS=PPB
#	
#	# This is to extract a subset of the PA data.
#	# 1 - 9999 gets all
#	CXR_PA_EXT_BEG_I_INDEX[1]=1
#	CXR_PA_EXT_END_I_INDEX[1]=9999
#	CXR_PA_EXT_BEG_J_INDEX[1]=1
#	CXR_PA_EXT_END_J_INDEX[1]=9999
#	CXR_PA_EXT_BEG_K_INDEX[1]=1
#	CXR_PA_EXT_END_K_INDEX[1]=9999
#
#	CXR_PA_EXT_BEG_I_INDEX[2]=1   
#	CXR_PA_EXT_END_I_INDEX[2]=9999
#	CXR_PA_EXT_BEG_J_INDEX[2]=1   
#	CXR_PA_EXT_END_J_INDEX[2]=9999
#	CXR_PA_EXT_BEG_K_INDEX[2]=1   
#	CXR_PA_EXT_END_K_INDEX[2]=9999
#	
#fi
#
#
#################################################################################
#### All following settings for OSAT, PSAT, DDM and RTRAC come from the       ###
#### sample file of CAMx 4.51. They are untested.			                       ###
#################################################################################
#
#################################################################################
## Probing settings: OSAT/PSAT
#################################################################################
#if [[ "$CXR_PROBING_TOOL" == "OSAT" || "$CXR_PROBING_TOOL" == "PSAT" || "$CXR_PROBING_TOOL" == "GOAT" || "$CXR_PROBING_TOOL" == "APCA"     ]] 
#then
#
#	CXR_SA_SUMMARY_OUTPUT=true
#	
#	CXR_SA_MASTER_SFC_OUTPUT=true
#	CXR_SA_NESTED_SFC_OUTPUT=true
#	CXR_SA_STRATIFY_BOUNDARY=true
#	CXR_SA_NUMBER_OF_SOURCE_REGIONS=10
#	CXR_SA_NUMBER_OF_SOURCE_GROUPS=3
#	CXR_USE_LEFTOVER_GROUP=false
#	CXR_NUMBER_OF_TIMING_RELEASES=0
#	CXR_PSAT_TREAT_SULFATE_CLASS=false
#	CXR_PSAT_TREAT_NITRATE_CLASS=true
#	CXR_PSAT_TREAT_SOA_CLASS=false
#	CXR_PSAT_TREAT_PRIMARY_CLASS=false
#	CXR_PSAT_TREAT_MERCURY_CLASS=false
#	CXR_PSAT_TREAT_OZONE_CLASS=false
#	
#	# OSAT Input Files
#	
#	CXR_SA_RECEPTOR_DEFINITIONS_INPUT_FILE='${CXR_INPUT_DIR}/sa.rcp.def.dat'
#	
#	##################Source group and grid specific########################
#	
#	# The first index is the source group, the second is the grid
#	CXR_SA_EMISS_GROUP_GRID_1_1_INPUT_FILE=''
#	
#	# OSAT FILE RULES non-specific
#	
#	# These are needed as input (last day)
#	CXR_SA_MASTER_RESTART_FILE_RULE='${CXR_OUTPUT_DIR}/SA/${CXR_RUN}.${CXR_YEAR_YESTERDAY}${CXR_MONTH_YESTERDAY}${CXR_DAY_YESTERDAY}.sa.inst'
#	CXR_SA_NESTED_RESTART_FILE_RULE='${CXR_OUTPUT_DIR}/SA/${CXR_RUN}.${CXR_YEAR_YESTERDAY}${CXR_MONTH_YESTERDAY}${CXR_DAY_YESTERDAY}.sa.finst'
#	
#	# These are needed as output (this day)
#	CXR_SA_MASTER_RESTART_OUT_FILE_RULE='${CXR_OUTPUT_DIR}/SA/${CXR_RUN}.${CXR_YEAR}${CXR_MONTH}${CXR_DAY}.sa.inst'
#	CXR_SA_NESTED_RESTART_OUT_FILE_RULE='${CXR_OUTPUT_DIR}/SA/${CXR_RUN}.${CXR_YEAR}${CXR_MONTH}${CXR_DAY}.sa.finst'
#	
#	##################Grid spcecific########################################
#	# These NEED the variable ${CXR_IGRID} somewhere  (the grid number)
#	
#	CXR_SA_SOURCE_AREA_MAP_FILE_RULE='${CXR_INPUT_DIR}/sa.src.area.map.g${CXR_IGRID}'
#	
#	##################Source group specific#################################
#	# These NEED the variable ${CXR_ISRCGROUP} somewhere (the source group number)
#	
#	CXR_SA_POINTS_GROUP_FILE_RULE='${CXR_INPUT_DIR}/ptsrc.${CXR_ISRCGROUP}.${CXR_DATE_RAW}.bin'
#	
#
#################################################################################
## Probing settings:DDM
#################################################################################
#elif [[ "$CXR_PROBING_TOOL" == "DDM"  ]] 
#then
#
#	CXR_DDM_MASTER_SFC_OUTPUT=true
#	CXR_DDM_NESTED_SFC_OUTPUT=true
#	CXR_DDM_STRATIFY_BOUNDARY=true
#	
#	CXR_DDM_NUMBER_OF_SOURCE_REGIONS=10
#	CXR_DDM_NUMBER_OF_SOURCE_GROUPS=1
#	CXR_NUMBER_OF_BC_SPECIES_GROUPS=1
#	CXR_NUMBER_OF_EM_SPECIES_GROUPS=2
#	CXR_NUMBER_OF_IC_SPECIES_GROUPS=1
#	
#	# DDM Input Files
#	
#	CXR_DDM_INITIAL_CONDITIONS_INPUT_FILE='ic.generic.bin'
#	CXR_DDM_BOUNDARY_CONDITIONS_INPUT_FILE='bc.generic.bin'
#	CXR_DDM_TOP_CONCENTRATIONS_INPUT_FILE='tc.generic'
#	CXR_DDM_RECEPTOR_DEFINITIONS_INPUT_FILE='ddm.rcp.def.dat'
#	
#	##################Source group and grid specific########################
#	
#	# The first index is the source group, the second is the grid
#	# You need one file rule for each element for the source group/grid matrix
#	CXR_DDM_EMISS_GROUP_GRID_1_1_FILE_RULE='emiss.utils_1.${CXR_DATE_RAW}.bin'
#	CXR_DDM_EMISS_GROUP_GRID_1_2_FILE_RULE='emiss.utils_2.${CXR_DATE_RAW}.bin'
#	CXR_DDM_EMISS_GROUP_GRID_1_3_FILE_RULE='emiss.utils_3.${CXR_DATE_RAW}.bin'
#	
#	# DDM FILE RULES non-specific
#	CXR_DDM_MASTER_RESTART_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW_YESTERDAY}.ddm.inst'
#	CXR_DDM_NESTED_RESTART_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW_YESTERDAY}.ddm.finst'
#	
#	CXR_EMIS_SPECIES_GROUPS[1]=O3
#	CXR_EMIS_SPECIES_GROUPS[1]=NOX
#	
#	CXR_IC_SPECIES_GROUPS[1]=O3
#	
#	CXR_BC_SPECIES_GROUPS[1]=O3
#	
#	
#	##################Grid spcecific########################################
#	# These NEED the variable ${CXR_IGRID} somewhere  (the grid number)
#	
#	CXR_DDM_SOURCE_AREA_MAP_FILE_RULE='ddm.src.area.map.g${CXR_IGRID}'
#	
#	##################Source group specific#################################
#	# These NEED the variable ${CXR_ISRCGROUP} somewhere (the source group number)
#	CXR_SA_POINTS_GROUP_INPUT_FILE_RULE='ptsrc.${CXR_ISRCGROUP}.${CXR_DATE_RAW}.bin' 
#
#################################################################################
## Probing settings:RTRAC
#################################################################################
#elif [[ "$CXR_PROBING_TOOL" == "RTRAC"  ]] 
#then
#
#	CXR_RT_PIG_SAMPLE=false
#	
#	# RTRAC Input Files
#	CXR_RT_INITIAL_CONDITIONS_INPUT_FILE=''
#	CXR_RT_BOUNDARY_CONDITIONS_INPUT_FILE=''
#	CXR_RT_TOP_CONCENTRATIONS_INPUT_FILE=''
#	CXR_RT_CHEMISTRY_PARAMETERS_INPUT_FILE='CAMx4.chemparam.rtrac_test'
#	CXR_RT_RECEPTOR_DEFINITIONS_INPUT_FILE='receptor.rtrac.test'
#	CXR_RT_POINT_SOURCES_INPUT_FILE='pt.rtrac.test'
#	
#	# RTRAC FILE RULES non-specific
#	CXR_RT_MASTER_RESTART_RESTART_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW_YESTERDAY}.rtrac.inst'
#	CXR_RT_NESTED_RESTART_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW_YESTERDAY}.rtrac.finst'
#	
#	##################Grid spcecific########################################
#	# These NEED the variable ${CXR_IGRID} somewhere  (the grid number)
#	
#
#fi