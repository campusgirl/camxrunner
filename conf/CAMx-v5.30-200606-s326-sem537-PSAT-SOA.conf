################################################################################
#
# Maintenance note: MUST BE KEPT UP TO DATE WITH installer/X.YZ/base.ask and templates/base.tpl
#
# Runner script for CAMx 4.42/4.51 - Configuration. 
# See http://people.web.psi.ch/oderbolz/CAMxRunner
# 
# Leave the next line intact, it is used for change detection
# Version: $Id: CAMx-v4.51-bafu-psat-2006-s326-sem084-bc-o3onlyconst.conf 8307 2012-03-30 06:37:40Z oderbolz $ 
#
# Written by Daniel C. Oderbolz (CAMxRunner@psi.ch),
# Released under the Creative Commons "Attribution-Share Alike 2.5 Switzerland"
# License, (http://creativecommons.org/licenses/by-sa/2.5/ch/deed.en)
################################################################################
# Who	When		What
# dco 	02.05.2008	Created
################################################################################
# TODO: 
################################################################################
#
# All Variables (except system variables like OMP*) names start with CXR_
#
# Output File names end with OUTPUT_FILE
# Input File names end with INPUT_FILE
# Directories with _DIR
# Output directories with OUTPUT_DIR
# Executables with _EXEC
#
# Arrays of files are called OUTPUT_ARR_FILES AND INPUT_ARR_FILES
#
# If a variable is called CXR_SOMETHING_RULE
# it is expanded automatically to yield CXR_SOMETHING.
#
# Really red the documentation on Rules (http://people.web.psi.ch/oderbolz/CAMxRunner#FileRules) 
# before using them.
#
# Strings which are used as Floating point numbers, but are integer, need a trailing .
#
# Arrays must have an index 0 with a Dummy entry, we work in Fortran Land here.
#
# Also, entries in arrays which contain spaces must be protected by
# single (') quotes, because arrays are exported as space separated list

################################################################################
# Mission
################################################################################

# Quickly describe this run
CXR_MISSION="PSAT run with sem537 (fixed agri/grass/seasonality) in summer"

################################################################################
# Timespan of simulation
################################################################################

# The Start of the simulation in YYYY-MM-DD notation
CXR_START_DATE=2006-06-01

# The Stop of the simulation in YYYY-MM-DD notation
# For some reason, we do not have data for 31. of december
CXR_STOP_DATE=2006-06-30


# Must be in HHMI Format, applies just to first and last day, all others are from 0000 to 2400
CXR_START_HOUR_FIRST_DAY=0000
CXR_STOP_HOUR_LAST_DAY=2400

# Timezone (0=UTC,5=EST,6=CST,7=MST,8=PST)
CXR_TIME_ZONE=0

# The Simulation intervals in Minutes (Floats!)
CXR_MAXIMUM_TIMESTEP=15.
CXR_MET_INPUT_FREQUENCY=60.
CXR_EMS_INPUT_FREQUENCY=60.
CXR_OUTPUT_FREQUENCY=60.

################################################################################
# Geometry of simulation
################################################################################

CXR_MAP_PROJECTION=LATLON # (LAMBERT,POLAR,UTM,LATLON)

################################################################################
# Grid definition
################################################################################

# How many grids are used?
CXR_NUMBER_OF_GRIDS=1

# Of course, more grids mean more settings down here

#Master grid (Floats)
CXR_MASTER_ORIGIN_XCOORD=-15.00       # deg SW corner of cell(1,1)
CXR_MASTER_ORIGIN_YCOORD=35.00        # deg SW corner of cell (1,1)

# Floats
CXR_MASTER_CELL_XSIZE=0.250               # deg
CXR_MASTER_CELL_YSIZE=0.125               # deg


CXR_MASTER_GRID_COLUMNS=200
CXR_MASTER_GRID_ROWS=280

CXR_NUMBER_OF_LAYERS[1]=14
CXR_NUMBER_OF_LAYERS[2]=14

# Grid 0 and 1 are dummies
CXR_NEST_MESHING_FACTOR[0]=-
CXR_NEST_BEG_I_INDEX[0]=-
CXR_NEST_END_I_INDEX[0]=-
CXR_NEST_BEG_J_INDEX[0]=-
CXR_NEST_END_J_INDEX[0]=-
CXR_NUMBER_OF_LAYERS[0]=-

# This is a dummy because entries 1 are given by the MASTER settings
CXR_NEST_MESHING_FACTOR[1]=-
CXR_NEST_BEG_I_INDEX[1]=-
CXR_NEST_END_I_INDEX[1]=-
CXR_NEST_BEG_J_INDEX[1]=-
CXR_NEST_END_J_INDEX[1]=-

# Number of layers set above

# Second grid. Note that the WRF grid is 6 cells wider and higher
# because we need a border of one coarse cell (3 fine cells on either end)
CXR_NEST_MESHING_FACTOR[2]=3        # Relative to master grid
CXR_NEST_BEG_I_INDEX[2]=74          # Relative to master grid
CXR_NEST_END_I_INDEX[2]=113         # Relative to master grid
CXR_NEST_BEG_J_INDEX[2]=70          # Relative to master grid
CXR_NEST_END_J_INDEX[2]=119         # Relative to master grid
CXR_NUMBER_OF_LAYERS[2]=14
	
################################################################################
# Options for the export of station-specific data
################################################################################

main.source ${CXR_CONF_DIR}/bafu-psat_stations_small.conf

################################################################################
# Notification options
################################################################################
CXR_MAILADDR=daniel.oderbolz@psi.ch	
CXR_SMSNR=0765888275
CXR_SMSPROVIDER=sms.switch.ch
CXR_SMSADDR=${CXR_SMSNR}@${CXR_SMSPROVIDER}

#If this Variable is true, SMS will be sent
# Here, I want them only at daytime
CXR_SEND_SMS=$(common.date.isWallDaytime?)

# This string can be formatted as needed.
# I use it to create a row for a table in our Wiki.
# It will be output at the end of the log (expanded)
#
# Make sure, control sequences like \n are double-escaped (\\n)
# because the expansion otherwise removes the sequence

CXR_FINISH_MESSAGE_RULE='Please copy this into https://wiki.intranet.psi.ch/twiki/LAC/CAMxRuns \\n \| $(date +"%Y/%m/%d") \| ${USER} \| ${CXR_STATUS} \| ${CXR_RUN} \| ${CXR_START_DATE} \| ${CXR_STOP_DATE} \| ${CXR_BASE_DIR} \| http://people.web.psi.ch/oderbolz/CAMx/conf/$(basename "$CXR_CONFIG") \| http://people.web.psi.ch/oderbolz/CAMx/log/$(basename "$CXR_LOG") \| \\n'

################################################################################
# Model options (Solver etc.)
################################################################################
CXR_DIAGNOSTIC_ERROR_CHECK=false    # True=will stop before 1st timestep
# According to Chris, BOTT should take care of negative conc issues
CXR_ADVECTION_SOLVER=BOTT      # (PPM,BOTT)
CXR_CHEMISTRY_SOLVER=EBI      # (CMC,IEH,LSODE)

CXR_PROBING_TOOL=PSAT     # (None,OSAT,PSAT,GOAT,APCA,DDM,PA,RTRAC)
CXR_CHEMISTRY=true
CXR_DRY_DEPOSITION=true
CXR_WET_DEPOSITION=true
CXR_STAGGERED_WINDS=true
CXR_GRIDDED_EMISSIONS=true
CXR_POINT_EMISSIONS=false
CXR_IGNORE_EMISSION_DATES=true

CXR_TUV_CLOUD_ADJUST=true

# Generate PIG relevant code
CXR_PLUME_IN_GRID=false
CXR_PIG_SUBMODEL=None     # (None,GREASD,IRON)

################################################################################
# Chemical and aerosol Mechanism
################################################################################

# Here choose between these possibilities (taken from the CAMx Guide)
# 3 (Carbon Bond IV - Gery et al. 1989)
# 1 (same as above, but with reactive chlorine chemistry - Tanaka et al., 2000)
# 4 (Carbon Bond IV - CB4)
# 5 (SAPRC99, Carter, 2000)
# 6 (Carbon Bond version 2005 - CB05) 
# 7 (Carbon Bond version CB6) 
# 10 (User defined)

CXR_CHEMICAL_MECHANISM=6

# Choose between 
# CF for (Coarse fine) 
# CF+hg (Coarse fine with mercury)
# CMU (Carnegie Mellon sectional model) 
# NONE (No Aerosols)
# Aerosol Chemistry is currently only supported with mechanisms 4 and 6 - CAMxRunner will complain but try anyway
CXR_AEROSOL_MECHANISM=CF

# The CAMxRunner determines the name of the chemparam file automatically
# but you can overwrite this behavior by setting this parameter
# In this case it uses your setting
# CXR_CHEMPARAM_INPUT_FILE=


################################################################################
# Labels used for filenames
################################################################################
CXR_MET_PROJECT=a14
CXR_MET_SCENARIO=s326

# Either WRF or MM5
CXR_MET_MODEL=WRF

# Versionof the meteo model (not used for MM5)
CXR_MET_VERSION=3.2.1


CXR_EMMISS_PROJECT=${CXR_MET_PROJECT}
CXR_EMMISS_SCENARIO=sem537

CXR_CAMX_SCENARIO=${CXR_MET_SCENARIO}
CXR_CAMX_CUSTOMER=bafu-psat

CXR_STATION_LABEL=bafu-psat

################################################################################
# Directories 
# Attention: Put no variables in directory names that are not yet set here!
# E. g. any variable containing dates (like simulation year) will fail to expand!
################################################################################

CXR_BASE_DIR=/afs/psi.ch/intranet/LAC/projects/BAFU-PSAT/CAMxRuns/Runs/${CXR_RUN}
CXR_INPUT_DIR=${CXR_BASE_DIR}/Inputs
CXR_CONST_INPUT_DIR=/afs/psi.ch/intranet/LAC/projects/BAFU-PSAT/CAMxRuns/ConstInput

# Set Meteodir according to Model
case $CXR_MET_MODEL in

	MM5)
			CXR_METEO_DIR=/afs/psi.ch/intranet/LAC/keller_j/linuxmm5/out
			CXR_MET_PREFIX=camx
			CXR_LU_PREFIX=terrain
			CXR_TERR_POSTFIX=terrcamx
			
			;;
	WRF)
			CXR_METEO_DIR=/afs/psi.ch/intranet/LAC/keller_j/linuxwrf/out_${CXR_MET_VERSION}
			CXR_MET_PREFIX=camxw
			CXR_LU_PREFIX=geo
			CXR_TERR_POSTFIX=hgtx
			;;

esac

# Set landuse suffix
case ${CXR_DRYDEP_MODEL:-WESELY89} in

	WESELY89) CXR_LU_SUFFIX= ;;
	ZHANG03)	CXR_LU_SUFFIX=_26;;
	NONE)			CXR_LU_SUFFIX=;;
	*) main.dieGracefully "Unsupported Dry deposition model!";;

esac

CXR_LANDUSE_DIR=${CXR_METEO_DIR}/const

# Directory where to find MOZART global data.
# Here we use modified GEMS data
CXR_GLOBAL_CTM_DIR=/afs/psi.ch/intranet/LAC/projects/BAFU-PSAT/CAMxRuns/GEMS

CXR_EMISSION_DIR=${CXR_BASE_DIR}/Emiss
CXR_PTSRCE_DIR=${CXR_BASE_DIR}/Ptsrce

# Input preparation directories
CXR_EMISSION_SOURCE_DIR=/afs/psi.ch/intranet/LAC1/oderbolz/emiss/emisscamx

# This is the main output directory
CXR_OUTPUT_DIR=${CXR_BASE_DIR}/Outputs

# Probing output dirs
CXR_PA_OUTPUT_DIR=${CXR_OUTPUT_DIR}/PA
CXR_DDM_OUTPUT_DIR=${CXR_OUTPUT_DIR}/DDM
CXR_RT_OUTPUT_DIR=${CXR_OUTPUT_DIR}/RT
CXR_SA_OUTPUT_DIR=${CXR_OUTPUT_DIR}/SA

CXR_ASCII_OUTPUT_DIR=${CXR_OUTPUT_DIR}/ascii
CXR_STATION_OUTPUT_DIR=${CXR_OUTPUT_DIR}/Nabel


################################################################################
# Rules for filenames (See http://people.web.psi.ch/oderbolz/CAMxRunner#FileRules)
#
# There are more filerules in the Probing sections of this file
#
# These ABSOLUTELY need 'single quotes' around them, otherwise the shell expands them here!
################################################################################

################## Grid independent ############################################

# Input Preparation ############################################################


# Input ########################################################################

# The meteo files might have a different name on startup
CXR_DAY_METEO_FIRST_DAY_RULE='${CXR_DAY}'

CXR_PHOTOLYSIS_RATES_FILE_RULE='${CXR_INPUT_DIR}/tuv_${CXR_CAMX_CUSTOMER}_${CXR_YEAR_S}_${CXR_WOY}.out'
CXR_INITIAL_CONDITIONS_FILE_RULE='${CXR_INPUT_DIR}/ic_${CXR_CAMX_CUSTOMER}_moz-poa1ugm.bin'
CXR_BOUNDARY_CONDITIONS_FILE_RULE='${CXR_INPUT_DIR}/bc_${CXR_CAMX_CUSTOMER}_moz_${CXR_YEAR_S}${CXR_MONTH}${CXR_DAY}-poa1ugm.bin'
CXR_TOP_CONCENTRATIONS_FILE_RULE='${CXR_INPUT_DIR}/topconc_${CXR_CAMX_CUSTOMER}_${CXR_YEAR_S}.${CXR_ASC_EXT}'
CXR_ALBEDO_HAZE_OZONE_FILE_RULE='${CXR_INPUT_DIR}/ahomap_${CXR_CAMX_CUSTOMER}_1grid_${CXR_YEAR_S}_${CXR_WOY}.out'

CXR_POINT_SOURCES_FILE_RULE=''

# These are needed as input (last day)
CXR_MASTER_GRID_RESTART_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW_YESTERDAY}.inst'
CXR_NESTED_GRID_RESTART_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW_YESTERDAY}.finst'
# These are needed as output (this day)
CXR_MASTER_GRID_RESTART_OUT_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW}.inst'
CXR_NESTED_GRID_RESTARTT_OUT_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW}.finst'

# More restart rules in the probing sections later

CXR_PIG_RESTART_FILE_RULE=''

CXR_ROOT_OUTPUT_FILE_RULE='${CXR_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW}'

# File Roots for probing
CXR_PA_ROOT_OUTPUT_FILE_RULE='$CXR_PA_OUTPUT_DIR/${CXR_RUN}.${CXR_YEAR}${CXR_MONTH}${CXR_DAY}'

CXR_DDM_ROOT_OUTPUT_FILE_RULE='$CXR_DDM_OUTPUT_DIR/${CXR_RUN}.${CXR_YEAR}${CXR_MONTH}${CXR_DAY}'
CXR_RT_ROOT_OUTPUT_FILE_RULE='$CXR_RT_OUTPUT_DIR/${CXR_RUN}.${CXR_YEAR}${CXR_MONTH}${CXR_DAY}'
CXR_SA_ROOT_OUTPUT_FILE_RULE='$CXR_SA_OUTPUT_DIR/${CXR_RUN}.${CXR_YEAR}${CXR_MONTH}${CXR_DAY}'

# These are used 
#	* to prevent overwriting of existing files 
#	* the creation of the aqmfad directory
#	* to convert the binary output files
#	These are dependent on another rule - check the quoting!
CXR_DIAG_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.diag'
CXR_FINST_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.finst'
CXR_INST_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.inst'
CXR_MASS_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.mass'
CXR_OUT_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.out'

################## Extract station data (Station dependent)#####################################

# The local variable $station will be replaced by the actual name of the station in question
CXR_STATION_FILE_RULE='${CXR_STATION_OUTPUT_DIR}/${CXR_RUN}.${CXR_YEAR_S}${CXR_MONTH}${CXR_DAY}_${station}.dat'

# This is the name of the cumulated file
CXR_CUMULATIVE_STATION_FILE_RULE='${CXR_STATION_OUTPUT_DIR}/${CXR_STATION_LABEL}_${station}.txt'

################## Grid spcecific ##############################################

# These NEED the variable ${CXR_IGRID} somewhere (the grid number)

# Input Preparation ############################################################

# Emission (ll for LatLon)
CXR_EMISSION_ASC_FILE_RULE='${CXR_EMISSION_SOURCE_DIR}/${CXR_DATE_RAW}/${CXR_EMMISS_SCENARIO}/camxll_emiss_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_EMMISS_SCENARIO}_${CXR_DATE_RAW}.asc'
CXR_EMISSION_BIN_FILE_RULE='${CXR_EMISSION_DIR}/camxll_emiss_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_EMMISS_SCENARIO}_${CXR_DATE_RAW}.bin'


# Input ########################################################################

# This one is needed for initial and bounary conditions
CXR_MMOUT_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/wrfsfc_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}_${CXR_YEAR}${CXR_MONTH}${CXR_DAY}_save.dat'

#Landuse
CXR_LANDUSE_FILE_RULE='${CXR_CONST_INPUT_DIR}/${CXR_LU_PREFIX}_domain${CXR_IGRID}_${CXR_MET_PROJECT}_lucamx${CXR_LU_SUFFIX}.bin'

# Pressure
CXR_PRESSURE_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/${CXR_MET_PREFIX}_zp_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'

# Wind
CXR_WIND_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/${CXR_MET_PREFIX}_uv_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'

# Temperature
CXR_TEMPERATURE_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/${CXR_MET_PREFIX}_tp_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'

# Vapor
CXR_VAPOR_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/${CXR_MET_PREFIX}_qa_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'

# Cloud depends on CXR_TUV_CLOUD_ADJUST
CXR_CLOUD_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/${CXR_MET_PREFIX}_cr_$(common.math.if_then_else ${CXR_TUV_CLOUD_ADJUST:-false} DIAG_ "")domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'

# Vertical K
CXR_K_FILE_RULE='${CXR_METEO_DIR}/${CXR_DATE_RAW}/${CXR_MET_SCENARIO}/${CXR_MET_PREFIX}_kv_CMAQ_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}'
 
# Emissions (ll for LatLon)
CXR_EMISSION_FILE_RULE='${CXR_EMISSION_DIR}/camxll_emiss_domain${CXR_IGRID}_${CXR_EMMISS_PROJECT}_${CXR_EMMISS_SCENARIO}_${CXR_DATE_RAW}.bin'


# Output #######################################################################

#Deposition file (dependency -> quoting!)
CXR_DEPN_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.depn.grd0${CXR_IGRID}'

# The actual average file (THE OUTPUT) (dependency -> quoting!)
CXR_AVG_FILE_RULE=${CXR_ROOT_OUTPUT_FILE_RULE}'.avrg.grd0${CXR_IGRID}'  

# We create the ASCII version of thefiles in the aqmfad directory      
# All rules start with the CXR_ASCII_OUTPUT_DIR and end with ${CXR_ASC_EXT}
CXR_AVG_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_RUN}.${CXR_DATE_RAW}.avrg.grd0${CXR_IGRID}.${CXR_ASC_EXT}'

# Landuse ASCII File is provided by MM5, we will convert it to binary
CXR_LANDUSE_ASC_FILE_RULE='${CXR_LANDUSE_DIR}/${CXR_LU_PREFIX}_domain${CXR_IGRID}_${CXR_MET_PROJECT}_lucamx${CXR_LU_SUFFIX}.asce'

# Terrain elevation for aqmfad
CXR_TERRAIN_ASC_FILE_RULE='${CXR_LANDUSE_DIR}/${CXR_LU_PREFIX}_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_TERR_POSTFIX}.asce'

CXR_PRESSURE_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_MET_PREFIX}_zp_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}.${CXR_ASC_EXT}'
CXR_WIND_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_MET_PREFIX}_uv_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}.${CXR_ASC_EXT}'
CXR_TEMPERATURE_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_MET_PREFIX}_tp_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}.${CXR_ASC_EXT}'
CXR_VAPOR_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_MET_PREFIX}_qa_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}.${CXR_ASC_EXT}'
CXR_CLOUD_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_MET_PREFIX}_cr_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}.${CXR_ASC_EXT}'
CXR_K_ASC_FILE_RULE='${CXR_ASCII_OUTPUT_DIR}/${CXR_MET_PREFIX}_kv_CMAQ_domain${CXR_IGRID}_${CXR_MET_PROJECT}_${CXR_MET_SCENARIO}:${CXR_YEAR}-${CXR_MONTH}-${CXR_DAY_METEO}.${CXR_ASC_EXT}'		


################################################################################
# Preprocessors
################################################################################	

########################################
# albedo_haze_ozone (AHOMAP)
########################################

# Rules to generate the URL to get the ozone column (works form October 2004 on)
CXR_AHOMAP_OZONE_COLUMN_FILE_RULE='L3_ozone_omi_${CXR_DATE_RAW}.txt'
# Nesting of rule - attention with the quoting
CXR_AHOMAP_OZONE_COLUMN_URL_RULE='ftp://toms.gsfc.nasa.gov/pub/omi/data/ozone/Y${CXR_YEAR}/'${CXR_AHOMAP_OZONE_COLUMN_FILE_RULE}

# For data earlier than October 2004
#CXR_AHOMAP_OZONE_COLUMN_FILE_RULE='L3_ozone_epc_${CXR_DATE_RAW}.txt'
# Nesting of rule - attention with the quoting
#CXR_AHOMAP_OZONE_COLUMN_URL_RULE='ftp://toms.gsfc.nasa.gov/pub/eptoms/data/ozone/Y${CXR_YEAR}/'${CXR_AHOMAP_OZONE_COLUMN_FILE_RULE}

# This is where the files go
CXR_AHOMAP_OZONE_COLUMN_DIR=${CXR_PREPROCESSOR_ONCE_INPUT_DIR}/albedo_haze_ozone/ozone_column

# Should AHOMAP consider snow (boolean)
CXR_AHOMAP_SNOW=false

# How often do we run AHOMAP and TUV?
# currently supported: once, monthly, weekly
# if not set, once is assumed.
# In the case of weekly or monthly, 
# The filerules CXR_PHOTOLYSIS_RATES_FILE_RULE and CXR_ALBEDO_HAZE_OZONE_FILE_RULE
# need to contain CXR_WOY or CXR_MONTH, respectively
CXR_RUN_AHOMAP_TUV_INTERVAL=weekly

########################################
# photolysis_rates (TUV)
########################################

# Choose between these 2:
# 1 : pseudo-spherical two-stream delta-Eddington (ps2str.f) - fast
# 2 : discrete ordinates method (slower but more accurate)
CXR_TUV_RADIATIVE_TRANSFER_SCHEME=2

# This is a list of reaction numbers that need Photolysis rates 
# This depends on the chemistry parameters file!
# We try to make the correct guess here :-)

case "${CXR_CHEMICAL_MECHANISM}" in
		
			1 | 3 | 4 )
				# CB4 with updated isoprene chemistry (CAMx mechanisms 1, 3 and 4)
				CXR_TUV_REACTION_NUMBERS="4, 15, 16, 2, 17, 56"
				;;
				
			5)
				# SAPRC99 (Mechanism 5)
				CXR_TUV_REACTION_NUMBERS="100, 91, 90, 103, 85, 105"
				;;
			
			6)

				# CB05 (Mechanism 6)
				CXR_TUV_REACTION_NUMBERS="100, 122, 121, 102, 101, 125, 89, 126, 127, 128, 129, 86, 91, 90, 85, 130, 84, 131, 70"
				;;
				
			7) 
				# CB6 (Mechanism 7)
				CXR_TUV_REACTION_NUMBERS="97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 117, 118, 119, 114, 115, 116"
				;;
				
			*)	main.dieGracefully "The chemical mechanism ${CXR_CHEMICAL_MECHANISM} is not supported by this configuration file"
				;;

esac

CXR_TUV_NO_OF_REACTIONS=$(main.countDelimitedElements "$CXR_TUV_REACTION_NUMBERS" ",")

# This is stuff that we need to configure the CAMx compilation (camx.prm) and
# TUV operation. (TUV layer definition to calculate look-up table)
CXR_NOZN=5
CXR_NALB=5
CXR_NHAZ=3
CXR_NRUF=9
CXR_NHGHT=11
CXR_NZEN=10
CXR_NLU=11

# Now we need to indicate a height above ground for each of the CXR_NHGHT levels
CXR_TUV_HEIGHTS="0. 0.15 0.35 0.60 1.00 2.00 3.00 4.00 6.00 8.00 10.0"

########################################
# Preparation of IC/BC/TC
########################################

# Method that is used to determine ic/bc/tc
# Currently supported: MOZART, MOZART_INCREMENT, MOZART_CONSTANT or ICBCPREP
#
# MOZART uses the data from the MOZART global CTM
# MOZART_CONSTANT uses our preprocessor but replaces some of the MOZART data by constant values
# MOZART_INCREMENT allows to selectively increment certain species by a specified value (in PPM)
# ICBCPREP uses the ENVIRON preprocessor icbcprep (resulting in constant IC and BC data)

CXR_IC_BC_TC_METHOD=MOZART_CONSTANT

# Do the plots
CXR_IC_BC_TC_DO_PLOT=true

# Setup MOZART species, if needed
if [[ ${CXR_IC_BC_TC_METHOD:0:6} == MOZART ]]
then
	# This array describes the mapping of MOZART to CAMx species
	# Prior to 2004, MOZART provides only 5 species
	# The order is the same, so it is sufficient to change this parameter
	# in the config file
	
	# Unset first - it's an array!
	unset CXR_CAMX_MOZART_MAPPING
	
	# Syntax is CAMx:MOZART
	CXR_CAMX_MOZART_MAPPING[0]=O3:O3_VMR_inst
	CXR_CAMX_MOZART_MAPPING[1]=CO:CO_VMR_inst
	CXR_CAMX_MOZART_MAPPING[2]=FORM:CH2O_VMR_inst
	CXR_CAMX_MOZART_MAPPING[3]=NO:NO_VMR_inst
	CXR_CAMX_MOZART_MAPPING[4]=NO2:NO2_VMR_inst
	CXR_CAMX_MOZART_MAPPING[5]=HNO3:HNO3_VMR_inst
	CXR_CAMX_MOZART_MAPPING[6]=PNA:HO2NO2_VMR_inst
	CXR_CAMX_MOZART_MAPPING[7]=H2O2:H2O2_VMR_inst
	CXR_CAMX_MOZART_MAPPING[8]=PAN:PAN_VMR_inst
	CXR_CAMX_MOZART_MAPPING[9]=CH4:CH4_VMR_inst
	CXR_CAMX_MOZART_MAPPING[10]=ALD2:CH3CHO_VMR_inst
	CXR_CAMX_MOZART_MAPPING[11]=ETHA:C2H6_VMR_inst
	CXR_CAMX_MOZART_MAPPING[12]=ISOP:ISOP_VMR_inst
	CXR_CAMX_MOZART_MAPPING[13]=ISP:ISOP_VMR_inst
	CXR_CAMX_MOZART_MAPPING[14]=TOL:TOLUENE_VMR_inst
	CXR_CAMX_MOZART_MAPPING[15]=TOLA:TOLUENE_VMR_inst
	
	# Automatically count # species (no dummy)
	CXR_NUMBER_OF_GCTM_SPECIES=$(( ${#CXR_CAMX_MOZART_MAPPING[@]} ))
fi

if [[ "$CXR_IC_BC_TC_METHOD" != MOZART ]]
then
	# If we are not using MOZART, we need to define the constant values
	# or the increments.
	# If you are using MOZART_CONSTANT, you need to supply data for each element
	# of CXR_CAMX_MOZART_MAPPING because the preprocessors loops through that array

	# Here you need to define the species and the concentrations
	# (in ppm for gases, in ug/m**3 for aerosols) to use (format is "CAMXSPECIES:conc")
	# Depending on CXR_IC_BC_TC_METHOD, these are either increments or constant values.
	# Make sure the numbers are in Fortran 10.7 Format
	
	# Unset first - it's an array!
	unset CXR_IC_BC_TC_SPEC
	
	# we need different concentrations depending on season:
	# 50 ppm in summer, 45 in spring and autumn, 50 in summer
	
	case ${CXR_SEASON:-winter} in 
	
		summer)	main.log -a "Its summertime!"
						CXR_IC_BC_TC_SPEC[0]=O3:0.050
						;;
						
		winter) main.log -a "Its wintertime!" 
						CXR_IC_BC_TC_SPEC[0]=O3:0.040
						;;
						
		spring)	main.log -a "Its spring!" 
						CXR_IC_BC_TC_SPEC[0]=O3:0.045
						;; 

		autumn)	main.log -a "Its autumn!" 
						CXR_IC_BC_TC_SPEC[0]=O3:0.045
						;; 	

		*) 			main.dieGracefully "No valid season: ${CXR_SEASON}"
						;;
	
	esac
	
fi



########################################
# initial_conditions
########################################

# Where to find the GEMS gasphase files
CXR_GLOBAL_CTM_FILE_RULE='$CXR_GLOBAL_CTM_DIR/GRG_${CXR_YEAR}${CXR_MONTH}${CXR_DAY}_EU.nc'

# This is the IDL procedure for the initial_conditions generation
CXR_IC_PROC_INPUT_FILE=${CXR_PREPROCESSOR_ONCE_INPUT_DIR}/initial_conditions/camxinit.pro

########################################
# boundary_conditions
########################################

# This is the IDL procedure for the boundary_conditions generation
CXR_BC_PROC_INPUT_FILE=${CXR_PREPROCESSOR_DAILY_INPUT_DIR}/boundary_conditions/camxbound.pro

########################################
# split Emissions (PMCAMx 2008 only)
########################################

CXR_SPLIT_EMISSIONS_INPUT_FILE_RULE=''
CXR_SPLIT_EMISSIONS_OUTPUT_FILE_RULE=''

################################################################################
# Postprocessors
################################################################################

########################################
# extract_station_data
########################################	

# This is the IDL procedure for the extraction
# Because it is not executable, we treat it as an input file
CXR_STATION_PROC_INPUT_FILE=${CXR_POSTPROCESSOR_DAILY_INPUT_DIR}/extract_station_data/extract_nabel_stations.pro
CXR_RUN_EXTRACTION_ON_GRID=1

########################################
# aqmfad/emifad
########################################

# Aqmfad options
# This is treated like an array
#CXR_RUN_AQMFAD_ON_GRID="1 2 3"
CXR_RUN_AQMFAD_ON_GRID="1"

# the same for emifad
CXR_RUN_EMIFAD_ON_GRID="1"

################################################################################
# CAMxRunner specific settings
################################################################################

# Reload config each day
CXR_RELOAD_CONF=true

################################################################################
# If you want to disable modules of the CAMxRunner, do it here
################################################################################

# When set to false, disables check for disk space for model runs
CXR_CHECK_MODEL_SPACE_REQUIRED=false

# Set this to false to disable CAMx in this run
CXR_RUN_MODEL=true

# This string contains the space-separated module names of
# unwanted daily preprocessors like "create_emissions"
# If "${CXR_SKIP_ALL}" is given, all daily preprocessors are skipped

CXR_DISABLED_DAILY_PREPROC="${CXR_SKIP_ALL}"

# This string contains the space-separated  module names of
# unwanted one-time preprocessors.
# If "${CXR_SKIP_ALL}" is given, all one-time preprocessors are skipped

CXR_DISABLED_ONCE_PREPROC="${CXR_SKIP_ALL}"

# This string contains the space-separated module names of
# unwanted daily postprocessors
# If "${CXR_SKIP_ALL}" is given, all daily postprocessors are skipped
	
CXR_DISABLED_DAILY_POSTPROC="${CXR_SKIP_ALL}"
CXR_ENABLED_DAILY_POSTPROC="extract_station_data"


# This string contains the space-separated module names of
# unwanted one-time postprocessors.
# If "${CXR_SKIP_ALL}" is given, all one-time postprocessors are skipped

CXR_DISABLED_ONCE_POSTPROC="${CXR_SKIP_ALL}"
CXR_ENABLED_ONCE_POSTPROC="concatenate_station_data"

# This string contains the space-separated module names of
# unwanted model scripts.
# If "${CXR_SKIP_ALL}" is given, all one-time postprocessors are skipped
CXR_DISABLED_MODEL=""

# This string contains the space-separated module names of
# unwanted installers.
# If "${CXR_SKIP_ALL}" is given, all installers are skipped
CXR_DISABLED_INSTALLER=""

########################################
# Parallel Task execution
########################################

# Do we run processing parallel?
# This means that we use a number of backgroung processes
# to process all tasks an a way that respects the dependencies
# Can speed up things significantly.
CXR_PARALLEL_PROCESSING=false

# The number of processes is set later in the parallel (OMP) section

################################################################################
################################################################################
# Changes below this Comment are rather unusual
################################################################################
################################################################################

################################################################################
# Output specifications
################################################################################


# No 3D output
CXR_AVERAGE_OUTPUT_3D=false

CXR_HDF_FORMAT_OUTPUT=false


################################################################################
# Chemical species
################################################################################

# First unset array
unset CXR_OUTPUT_SPECIES_NAMES

# Entry 0 is a dummy, we want our arrays to start with index 1
CXR_OUTPUT_SPECIES_NAMES[0]=-
CXR_OUTPUT_SPECIES_NAMES[1]=NO
CXR_OUTPUT_SPECIES_NAMES[2]=NO2
CXR_OUTPUT_SPECIES_NAMES[3]=O3
CXR_OUTPUT_SPECIES_NAMES[4]=TOL
CXR_OUTPUT_SPECIES_NAMES[5]=XYL
CXR_OUTPUT_SPECIES_NAMES[6]=FORM
CXR_OUTPUT_SPECIES_NAMES[7]=PAN
CXR_OUTPUT_SPECIES_NAMES[8]=CO
CXR_OUTPUT_SPECIES_NAMES[9]=HONO
CXR_OUTPUT_SPECIES_NAMES[10]=HNO3
CXR_OUTPUT_SPECIES_NAMES[11]=H2O2
CXR_OUTPUT_SPECIES_NAMES[12]=ISOP
CXR_OUTPUT_SPECIES_NAMES[13]=PNA
CXR_OUTPUT_SPECIES_NAMES[14]=SO2
CXR_OUTPUT_SPECIES_NAMES[15]=NH3
CXR_OUTPUT_SPECIES_NAMES[16]=PH2O
CXR_OUTPUT_SPECIES_NAMES[17]=PNO3
CXR_OUTPUT_SPECIES_NAMES[18]=PSO4
CXR_OUTPUT_SPECIES_NAMES[19]=PNH4
CXR_OUTPUT_SPECIES_NAMES[20]=POA
CXR_OUTPUT_SPECIES_NAMES[21]=PEC
CXR_OUTPUT_SPECIES_NAMES[22]=SOA1
CXR_OUTPUT_SPECIES_NAMES[23]=SOA2
CXR_OUTPUT_SPECIES_NAMES[24]=SOA3
CXR_OUTPUT_SPECIES_NAMES[25]=SOA4
CXR_OUTPUT_SPECIES_NAMES[26]=SOA5
CXR_OUTPUT_SPECIES_NAMES[27]=SOA6
CXR_OUTPUT_SPECIES_NAMES[28]=SOA7
CXR_OUTPUT_SPECIES_NAMES[29]=SOPA
CXR_OUTPUT_SPECIES_NAMES[30]=SOPB
CXR_OUTPUT_SPECIES_NAMES[31]=NA
CXR_OUTPUT_SPECIES_NAMES[32]=PCL
CXR_OUTPUT_SPECIES_NAMES[33]=FPRM
CXR_OUTPUT_SPECIES_NAMES[34]=FCRS
CXR_OUTPUT_SPECIES_NAMES[35]=CPRM
CXR_OUTPUT_SPECIES_NAMES[36]=CCRS
# We added a couple of species
CXR_OUTPUT_SPECIES_NAMES[37]=TERP
CXR_OUTPUT_SPECIES_NAMES[38]=CG1
CXR_OUTPUT_SPECIES_NAMES[39]=CG2
CXR_OUTPUT_SPECIES_NAMES[40]=CG3
CXR_OUTPUT_SPECIES_NAMES[41]=CG4
CXR_OUTPUT_SPECIES_NAMES[42]=CG5
CXR_OUTPUT_SPECIES_NAMES[43]=CG6
CXR_OUTPUT_SPECIES_NAMES[44]=CG7
CXR_OUTPUT_SPECIES_NAMES[45]=MEOH
CXR_OUTPUT_SPECIES_NAMES[46]=FORM
CXR_OUTPUT_SPECIES_NAMES[47]=FACD
CXR_OUTPUT_SPECIES_NAMES[48]=ETOH
CXR_OUTPUT_SPECIES_NAMES[49]=ALD2
CXR_OUTPUT_SPECIES_NAMES[50]=AACD

# Automatically count # species (subtract 1 for dummy)
CXR_NUMBER_OF_OUTPUT_SPECIES=$(( ${#CXR_OUTPUT_SPECIES_NAMES[@]} - 1 ))


################################################################################
# The OPM settings are machine-dependent.
################################################################################ 
# Are we on a multicore system?
CXR_NUMBER_OF_CORES=$(main.countCores)

# Maximal number of parallel processes in the CAMxRunner
if [[ "$CXR_PARALLEL_PROCESSING" == true  ]]
then
	# By default, use the number of cores
	CXR_MAX_PARALLEL_PROCS=$CXR_NUMBER_OF_CORES
else
	# Non-Parallel use 1 process
	CXR_MAX_PARALLEL_PROCS=1
fi

# This can be either None, OMP or MPI (MPI needs CAMx 5.x or higher). OMP is recommended.
# the CAMx executable must provide this!
CXR_PARALLEL_PARADIGM=OMP

################################################################################
# OpenMP settings
################################################################################
# Switch on OMP
# If OMP_NUM_THREADS=1, OMP is turned off

# Set number of OpenMP threads (to be nice, we use only half of the available cores)
export OMP_NUM_THREADS=$(( $CXR_NUMBER_OF_CORES / 2 ))


# Per Thread stack size. Can lead to problems if both to large or too small...
export MPSTKZ=128M

################################################################################
# Determine name of executable.
################################################################################

# If you need another executable name,
# set this value to a full path.
# CXR_MODEL_EXEC=

#################################################################################
## Probing settings: OSAT/PSAT
#################################################################################
if [[    "$CXR_PROBING_TOOL" == "OSAT" || "$CXR_PROBING_TOOL" == "PSAT" || "$CXR_PROBING_TOOL" == "GOAT" || "$CXR_PROBING_TOOL" == "APCA"     ]] 
then

	# We re-use an existing file
	CXR_PSAT_CREATE_RECEPTOR_FILE=false

	# Logical flag used to limit the species written to the tracer
	# concentration file to a subset of the PSAT treated species.
	CXR_SA_SUMMARY_OUTPUT=false
	CXR_SA_RECEPTOR=true
	CXR_SA_MASTER_SFC_OUTPUT=true
	CXR_SA_NESTED_SFC_OUTPUT=true
	CXR_SA_STRATIFY_BOUNDARY=true
	CXR_SA_NUMBER_OF_SOURCE_REGIONS=6
	CXR_SA_NUMBER_OF_SOURCE_GROUPS=1
	SA_REGIONS_DOMAIN_NUMBERS=( - 1) # array of domain numbers "containing" source regions. "-" is a dummy
	CXR_USE_LEFTOVER_GROUP=true
	CXR_NUMBER_OF_TIMING_RELEASES=0
	CXR_PSAT_TREAT_SULFATE_CLASS=false
	CXR_PSAT_TREAT_NITRATE_CLASS=false
	CXR_PSAT_TREAT_SOA_CLASS=true
	CXR_PSAT_TREAT_PRIMARY_CLASS=true
	CXR_PSAT_TREAT_MERCURY_CLASS=false
	CXR_PSAT_TREAT_OZONE_CLASS=true
	
	# expected output files (non-grid specific)

	# SA files automaticall get .sa. added
	CXR_SA_FINST_FILE_RULE=${CXR_SA_ROOT_OUTPUT_FILE_RULE}'.sa.finst'
	CXR_SA_INST_FILE_RULE=${CXR_SA_ROOT_OUTPUT_FILE_RULE}'.sa.inst'
	
	# expected output files (grid specific)
	CXR_SA_AVG_FILE_RULE=${CXR_SA_ROOT_OUTPUT_FILE_RULE}'.sa.grd0${CXR_IGRID}'
	
	# O/PSAT Input Files
	
	# CAMxRunner can create a Receptor file from the configuration:
	if [[ "$CXR_SA_RECEPTOR" == "true"  ]]
	then
		# Needed for writing receptor file
		CXR_SA_RECEPTOR_FILE_RULE=${CXR_SA_ROOT_OUTPUT_FILE_RULE}'.sa.receptor'
		
		SA_POINT_RECEPTOR=true
		SA_SINGLE_CELL_RECEPTOR=true
		SA_CELL_AVERAGE_RECEPTOR=true
		SA_WALL_OF_CELLS_RECEPTOR=false
		
		#### POINT Receptors:
		if [[ "$SA_POINT_RECEPTOR" == "true" ]]
		then
		
			# We re-use the stations as receptors
			SA_POINT_RECEPTOR_NAMES=( - ${CXR_PSAT_POINTS[@]} ) # not more then 10 chars per name!
			SA_POINT_X_COORD=( - ${CXR_STATION_X_MODEL[@]} ) # In model coordinates
			SA_POINT_Y_COORD=( - ${CXR_STATION_Y_MODEL[@]} ) # In model coordinates
			
			SA_POINT_NUMBER=$(( ${#SA_POINT_RECEPTOR_NAMES[@]} - 1 ))

			if [[ $SA_POINT_NUMBER -le "0"  ]] 
			then 
				main.dieGracefully "SA Receptor file: no entry in SA_POINT_RECEPTOR_NAMES"
			fi
			
			# test for each array and each element if #char -le 10!
			for iPointReceptor in $(seq 1 $SA_POINT_NUMBER);
			do
				case ${SA_POINT_RECEPTOR_NAMES[0]} in
					-)
					if [[ ${#SA_POINT_RECEPTOR_NAMES[$iPointReceptor]} -gt "10" ]] 
					then 
						main.dieGracefully "SA Receptor file: too many chars on index $iPointReceptor in SA_POINT_RECEPTOR_NAMES"
					fi
					;;
					*)
					main.dieGracefully "SA Receptor file: no dummy entry on index 0 in SA_POINT_RECEPTOR_NAMES";
					;;
				esac
			done

			# test if arrays have the same length

			if [[ ${#SA_POINT_X_COORD[@]} -ne ${#SA_POINT_RECEPTOR_NAMES[@]}  ]] 
			then 
				main.dieGracefully "SA Receptor file: number of receptor sites in SA_POINT_RECEPTOR_NAMES and SA_POINT_X_COORD are not consistent"
			fi
			
			if [[ ${#SA_POINT_Y_COORD[@]} -ne ${#SA_POINT_RECEPTOR_NAMES[@]}  ]] 
			then 
				main.dieGracefully "SA Receptor file: number of receptor sites in SA_POINT_RECEPTOR_NAMES and SA_POINT_Y_COORD are not consistent"
			fi

		fi # point-receptors
		
		
		#### SINGLE CELL Receptors:
		if [[ "$SA_SINGLE_CELL_RECEPTOR" == "true"  ]]
		then
		
			SA_SCELL_RECEPTOR_NAMES=( - ${CXR_PSAT_CELLS[@]} ) # not more then 10 chars per name!
			# do we have to check at the end if every recname is unique?
			SA_SCELL_GRID_NUMBER=( - ) 
			SA_SCELL_XNUMBER=( - ${CXR_STATION_X_MODEL_INDEXES[@]} ) 
			SA_SCELL_YNUMBER=( - ${CXR_STATION_Y_MODEL_INDEXES[@]} )
			SA_SCELL_NUMBER=$(( ${#SA_SCELL_RECEPTOR_NAMES[@]} - 1 ))
			
			for iStation in $(seq 1 $SA_SCELL_NUMBER)
			do
				# All these cells are grid 1
				SA_SCELL_GRID_NUMBER[$iStation]=1
			done
			
			if [[ $SA_SCELL_NUMBER -le "0"  ]] 
			then 
				main.dieGracefully "SA Receptor file: no entry in SA_SCELL_RECEPTOR_NAMES"
			fi

		fi # single-cell
		
		
		#### CELL AVERAGE Receptors:
		if [[ "$SA_CELL_AVERAGE_RECEPTOR" == "true"  ]]
		then
			SA_CELLAVG_RECEPTOR_NAMES=( - Jura Plateau Prealpine Alps SoAlps ) # not more then 10 chars per name!
			
			# These are grid cells in D1
			SA_CELLAVG_GRID_NUMBER=( - 1 1 1 1 1 ) 
			SA_CELLAVG_NUMBER_OF_CELLS=( - 22 39 24 66 14 )
			SA_CELLAVG_XNUMBER=( - 85 85 85 86 87 87 88 88 88 89 90 89 90 91 89 90 91 92 93 91 92 93 - 85 86 86 87 88 87 88 88 89 90 89 90 89 90 91 93 94 91 92 93 94 92 93 94 95 96 94 95 96 97 98 94 95 96 97 98 95 96 95 - 88 89 89 90 89 90 91 91 92 93 91 92 93 94 92 95 96 99 95 96 99 97 98 99 - 89 90 92 88 89 90 91 92 88 89 90 91 92 88 89 90 91 92 93 99 90 91 92 93 99 100 91 92 93 94 97 98 99 100 102 92 93 94 95 96 97 98 99 100 102 94 95 96 97 98 99 100 101 102 95 96 97 98 99 100 101 102 97 98 97 98 - 96 95 96 97 95 96 97 101 95 96 97 101 95 96)
			SA_CELLAVG_YNUMBER=( - 91 92 93 94 95 96 96 97 98 98 98 99 99 99 100 100 100 100 100 101 101 101 - 90 92 93 93 93 94 94 95 95 95 96 96 97 97 97 97 97 98 98 98 98 99 99 99 99 99 100 100 100 100 100 101 101 101 101 101 102 102 103 - 92 92 93 93 94 94 94 95 95 95 96 96 96 96 97 97 97 97 98 98 98 99 99 100 - 88 88 88 89 89 89 89 89 90 90 90 90 90 91 91 91 91 91 91 91 92 92 92 92 92 92 93 93 93 93 93 93 93 93 93 94 94 94 94 94 94 94 94 94 94 95 95 95 95 95 95 95 95 95 96 96 96 96 96 96 96 96 97 97 98 98 - 89 90 90 90 91 91 91 91 92 92 92 92 93 93)
			SA_CELLAVG_NUMBER=$(( ${#SA_CELLAVG_RECEPTOR_NAMES[@]} - 1 ))
			
			if [[ $SA_CELLAVG_NUMBER -le "0"  ]] 
			then 
				main.dieGracefully "SA Receptor file: no entry in SA_CELLAVG_RECEPTOR_NAMES"
			fi

			case "${#SA_CELLAVG_NUMBER_OF_CELLS[@]}" in
				0 | 1)
				main.dieGracefully "SA Receptor file: no entry in SA_CELLAVG_NUMBER_OF_CELLS";
				;;
				2)
				SA_CELLAVG_DUMMIES=0;
				;;
				*)
				SA_CELLAVG_DUMMIES[0]=0
				for iCellavg in $(seq 1 $(( ${#SA_CELLAVG_NUMBER_OF_CELLS[@]} - 2 )))
				do
					SA_CELLAVG_DUMMIES[$iCellavg]=$(( ${SA_CELLAVG_DUMMIES[$(( $iCellavg - 1 ))]} + ${SA_CELLAVG_NUMBER_OF_CELLS[$iCellavg]} + 1 )) 
				done
				;;
			esac

		fi # cell-average
		
		
		#### WALL OF CELLS Receptors:
		if [[ "$SA_WALL_OF_CELLS_RECEPTOR" == "true"  ]]
		then
			SA_CELLWALL_RECEPTOR_NAMES=( - ) # not more then 10 chars per name!
			# do we have to check at the end if every recname is unique?
			SA_CELLWALL_GRID_NUMBER=( - ) 
			SA_CELLWALL_XSTART=( - )
			SA_CELLWALL_XEND=( - )			
			SA_CELLWALL_YSTART=( - )
			SA_CELLWALL_YEND=( - )
			SA_CELLWALL_ZSTART=( - )
			SA_CELLWALL_ZEND=( - )
			SA_CELLWALL_NUMBER=$(( ${#SA_CELLWALL_RECEPTOR_NAMES[@]} - 1 ))
			if [[ $SA_CELLWALL_NUMBER -le "0"  ]] 
			then 
				main.dieGracefully "SA Receptor file: no entry in SA_CELLWALL_RECEPTOR_NAMES"
			fi 
			
		fi # wall?

		# set file rule
		CXR_SA_RECEPTOR_DEFINITIONS_FILE_RULE='${CXR_INPUT_DIR}/sa.rcp.def.dat'

	fi # receptors?
	
	##################Source group and grid specific########################
	
	# The first index is the source group, the second is the grid
	# Needs to contain ${CXR_IGRID} (domain number) ${CXR_ISRCGROUP} (source group number) 
	CATEG_NAME[1]=

	# We currently use just one category.
	
	CXR_SA_EMISS_GROUP_GRID_INPUT_FILE_RULE=$CXR_EMISSION_FILE_RULE
	
	# SA FILE RULES non-specific
	
	# These are needed as input (last day)
	CXR_SA_MASTER_RESTART_FILE_RULE='${CXR_OUTPUT_DIR}/SA/${CXR_RUN}.${CXR_YEAR_YESTERDAY}${CXR_MONTH_YESTERDAY}${CXR_DAY_YESTERDAY}.sa.inst'
	CXR_SA_NESTED_RESTART_FILE_RULE='${CXR_OUTPUT_DIR}/SA/${CXR_RUN}.${CXR_YEAR_YESTERDAY}${CXR_MONTH_YESTERDAY}${CXR_DAY_YESTERDAY}.sa.finst'
	
	# These are needed as output (this day)
	CXR_SA_MASTER_RESTART_OUT_FILE_RULE='${CXR_OUTPUT_DIR}/SA/${CXR_RUN}.${CXR_YEAR}${CXR_MONTH}${CXR_DAY}.sa.inst'
	CXR_SA_NESTED_RESTART_OUT_FILE_RULE='${CXR_OUTPUT_DIR}/SA/${CXR_RUN}.${CXR_YEAR}${CXR_MONTH}${CXR_DAY}.sa.finst'
		
	##################Grid spcecific########################################
	# These NEED the variable ${SA_REGIONS_DOMAIN_NUMBERS[${CXR_ISRCREGION}]} somewhere  (the domain number)
	
	CXR_SA_SOURCE_AREA_MAP_FILE_RULE='${CXR_CONST_INPUT_DIR}/source_area_map_${CXR_MET_PROJECT}_domain${SA_REGIONS_DOMAIN_NUMBERS[${CXR_ISRCREGION}]}.asc'
	
	##################Source group specific#################################
	# These NEED the variable ${CXR_ISRCGROUP} somewhere (the source group number)
	
	CXR_SA_POINTS_GROUP_FILE_RULE='${CXR_INPUT_DIR}/ptsrc.${CXR_ISRCGROUP}.${CXR_DATE_RAW}.bin'
	
fi


# we will not compress output
CXR_COMPRESS_OUTPUT=false

CXR_LOAD_EXIT_THRESHOLD=1000