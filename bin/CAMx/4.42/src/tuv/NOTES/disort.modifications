Sasha, 

I tried to describe as accurately as possible what we did
to disort.f and why we think these are valid modifications.

If you have any questions, please ask...

Oh, by the way, that "funny if-statement" that needed to
be pulled apart and rewritten as a nested if was included
in the _old_ version of disort, Stamnes et al. have
already changed it to a nested if in the new version.

Sorry about the confusion!

Siri

*-------------------------------------------------------------

Modifications to subroutine ASYMTX in disort.f to avoid a
"subscript out of bounds" error when array bound checking
AND code optimization are switched on

1. Modification necessary for use with CRAY cf77 compiling
   system:


      DO 480 J = LB, N2
         I  = N2 + LB - J
         Z  = AAD( I, I )
         R  = X - Z
         S  = Y - Z
         P  = ( R*S - W ) / AAD( I + 1, I ) + AAD( I, I + 1 )
         Q  = AAD( I + 1, I + 1 ) - Z - R - S
         R  = AAD( I + 2, I + 1 )
         S  = ABS( P ) + ABS( Q ) + ABS( R )
         P  = P / S
         Q  = Q / S
         R  = R / S

         IF( I.EQ.LB ) GO TO  490

         UU   = ABS( AAD( I, I-1 ) )*( ABS( Q ) + ABS( R ) )
         VV   = ABS( P ) * ( ABS( AAD( I-1, I-1 ) ) + ABS( Z ) +
     &                       ABS( AAD( I+1, I+1 ) ) )

         IF( UU .LE. TOL*VV ) GO TO  490

  480 CONTINUE

  A run time error (subscript out of bounds) occurs right
  after this loop.   Apparently, vectorization of this loop
  causes a faulty evaluation of the IF (I.EQ.LB) ...
  statement.  Including a CDIR$ NEXTSCALAR prior to the
  loop prevents vectorization and makes the run time error
  disappear. 

  Another solution is to alter the code slightly, so that it
  reads

      DO 480 J = LB, N2
         I  = N2 + LB - J
         Z  = AAD( I, I )
         R  = X - Z
         S  = Y - Z
         P  = ( R*S - W ) / AAD( I + 1, I ) + AAD( I, I + 1 )
         Q  = AAD( I + 1, I + 1 ) - Z - R - S
         R  = AAD( I + 2, I + 1 )
         S  = ABS( P ) + ABS( Q ) + ABS( R )
         P  = P / S
         Q  = Q / S
         R  = R / S

C        IF( I.EQ.LB ) GO TO  490
         IF( I.NE.1 ) THEN

         UU   = ABS( AAD( I, I-1 ) )*( ABS( Q ) + ABS( R ) )           !S1
         VV   = ABS( P ) * ( ABS( AAD( I-1, I-1 ) ) + ABS( Z ) +       !S2
     &                       ABS( AAD( I+1, I+1 ) ) )                  !S3

         IF( UU .LE. TOL*VV ) GO TO  490                               !S4
         ENDIF

  480 CONTINUE

  This modification does not inhibit vectorization.

  This is a valid modification:

  - I = LB if and only if J = N2 (which is the upper loop boundary)
    which means that omitting this IF statement alltogether
    will - in the worst case - result in one additional execution 
    of the lines marked S1-S4 above.

  - One additional execution of S1-S4 causes another re-definition of 
    UU and VV, but these variables are never referrenced thereafter,
    except for evaluation of condition S4.  Since the original IF
    statement would have branched to the same statement number as
    S4 (if the condition is met), and because statement number 490
    immediately follows the 480-loop, the program flow has not been
    disturbed.

  - To avoid a run time error, "I" must meet the condition "I > 1"
    (which is equivalent to "I .NE. 1" in this case, because I>0),
    otherwise S1 will cause a "subscript out of bounds" error.


2.  Modifications necessary for use with xlf under IBM AIX:

  430 CONTINUE
      X  = AAD( N, N )

      IF( LB.EQ.N ) THEN                  !S1
c                                        ** One eigenvalue found
         AAD( N, N ) = X + T
         EVALD( N ) = AAD( N, N )
         N  = N1                          
         GO TO  400                       

      END IF

      Y  = AAD( N1, N1 )                  !S2
      W  = AAD( N, N1 )*AAD( N1, N )      

    With optimization set to level 2 or higher, a faulty evaluation 
    of IF statement S1 can occur (cause unknown, we suspect a failure
    to copy register contents back to memory in the loop prior to this
    code block).  We have seen this happen only if N = 1 (for which
    N1 = N-1 = 0).  LB.EQ.N should be true, but is faulty evaluated
    as .FALSE., which then causes a subscript out of bounds at
    statement S2.

    Modifying the code so that it reads

  430 CONTINUE
      X  = AAD( N, N )

      IF( LB.EQ.N ) THEN                  !S1
c                                        ** One eigenvalue found
         AAD( N, N ) = X + T
         EVALD( N ) = AAD( N, N )
         N  = N1                          
         GO TO  400                       

      END IF

      IF ((N .LE. 1) .OR. (N1 .LE. 1)) THEN
         WRITE(0,*) 'Subscript out of bounds'  !E1
         STOP 9999                             !E2
      ENDIF

      Y  = AAD( N1, N1 )                  !S2
      W  = AAD( N, N1 )*AAD( N1, N )      


    makes the run time error disappear.  This is most probably
    due to the fact that the I/O-statement inhibits omptimization
    of this portion of the code.  Another reason could be that
    the I/O-statement forces emptying registers due to its
    complexity.

    With this modification, we have never seen the error
    message being printed (E1), and the program never ran
    into the STOP (E2).
