      program camxtrct
c
c-----------------------------------------------------------------------
c
c     CAMxtrct extracts concentrations for a single species from CAMx 
c     coarse and/or fine AVERAGE files.  It then either writes an output
c     file in UAM average file format or in an ASCII format (similar 
c     to Golden Software Surfer GRD format).  CAMxtrct can also extract
c     and sum emissions data for one species from EMISSIONS or PTSOURCE
c     files.  The output format for EMISSIONS data is Surfer GRD and the
c     output for PTSOURCE data is columnated data in Surfer DAT format.
c
c     A number of extraction options are available, based on the selection
c     of the following key words:
c       XYHOUR   N-hourly X-Y extraction for one layer 
c       XZHOUR   N-hourly X-Z extraction for one row
c       YZHOUR   N-hourly Y-Z extraction for one column
c       XYMAX    Maximum (over duration of file) X-Y extraction for one layer
c       XZMAX    Maximum (over duration of file) X-Z extraction for one row
c       YZMAX    Maximum (over duration of file) Y-Z extraction for one column
c       TIMSER   Time series of observations and predictions
c       EMISS    X-Y area emissions summed over duration of file 
c       PTSRCE   point emissions summed over duration of file
c     where the interval of N-hourly extractions, layer, row, and
c     column indices are user-specified.  CAMXTRCT ignores index
c     specifications for EMISS and PTSRCE options.
c     (XZ*, YZ*, and TIMSER are not supported by this version)
c
c     The user may select extractions for certain grids, based on the
c     selection of the following key words:
c       COARSE   Extracts data for coarse grid only
c       FINE     Extracts data for specific fine grid (user supplies grid index)
c       ALL      Extracts data for all grids, and outputs the results at
c                the horizontal resolution of the finest grid
c     Only one grid is processed for the EMISS and PTSRCE options, so these
c     key words are ignored in these cases
c
c     The user may select XY* extractions for certain layers, based on the
c     selection of the following key words:
c       SURFCE   Extracts data from grid(s) for layer 1
c       ALOFT    Extracts data from grid(s) for a user-specified layer,
c                indexed to the coarsest grid (fine layers spanning this
c                layer will be aggregated)
c     These key words are ignored for EMISS, PTSRCE, XZ*, YZ*, and TIMSER
c     options
c
c     The user may select one species (e.g., O3) on file for processing,
c     or one "parameter" defined by the following key words:
c       NOX      NO + NO2
c       NOY      NO + NO2 + PAN + HNO2 + HNO3 + NXOY + NTR
c       VOC      ETH + OLE + PAR + TOL + XYL + FORM + ALD2 + ISOP + 
c                ETOH + MEOH + ISPD
c       AAA/BBB  ratio of two species or parameters (e.g., VOC/NOX)
c     OSAT tracer species, and combinations thereof, are also supported
c     (e.g., TNOX, TVOC, TO3, TO3N, TO3V)
c
c     One of three files types is generated by CAMXTRCT, based on user
c     selection.  If ASCII is selected, a SURFER-compatible GRD file is
c     written for all options except PTSOURCE, for which a columnated DAT
c     file is written for "bubble" plots.  The program supports ASCII
c     output for all options.  If BINARY is selected, a CAMx coarse grid
c     Fortran binary output file is written; the program supports BINARY
c     output for XY* options only.
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Copyright (C) 1998  ENVIRON
c 
c This program is free software; you can redistribute it and/or
c modify it under the terms of the GNU General Public License
c as published by the Free Software Foundation; either version 2
c of the License, or (at your option) any later version.
c 
c This program is distributed in the hope that it will be useful,
c but WITHOUT ANY WARRANTY; without even the implied warranty of
c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
c GNU General Public License for more details.
c
c To obtain a copy of the GNU General Public License
c write to the Free Software Foundation, Inc., 
c 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c-----------------------------------------------------------------------
c   Log:
c     05/14/98  Added capability to extract specific layers from
c               specific grids
c-----------------------------------------------------------------------
c
c-----------------------------------------------------------------------
c   Include files:
c-----------------------------------------------------------------------
c
      include 'camxtrct.inc'
c
c-----------------------------------------------------------------------
c   External functions:
c-----------------------------------------------------------------------
c
      integer*4 strlen
c
c-----------------------------------------------------------------------
c   Local variables:
c-----------------------------------------------------------------------
c
      character*10 lvltyp
      integer*4    ierr, hrct, spct, idate, ibeghr, jdate, iendhr
      integer*4    level, i, j, n, ihour, igrd, idatfg, ibegfg, izpfl
      real*4       cnctmp(MXCELL,MXCELL,MXLAYR), totems, totday
      real*4       cncgrd(MXCELL,MXCELL,MXLAYR), zmin, zmax
      real*4       conc2d(MXCELL,MXCELL)
      logical*4    lusehr, lfirst, lzero, lmax
c
c-----------------------------------------------------------------------
c   Entry point:
c-----------------------------------------------------------------------
c
c  --- call routine to read the user inputs ---
c
      call userin (ierr) 
      if( ierr .NE. ISUCES ) goto 9999
c
c  --- call routine to read the header, based on the type of file ---
c
      call rdhdcg (ierr)
      if( ierr .NE. ISUCES ) goto 9999
      if( avgtyp .EQ. ALL .OR. avgtyp .EQ. FINE ) then
        call rdhdfg (ierr)
        if( ierr .NE. ISUCES ) goto 9999 
      endif
c
c  --- call routine to check the species to be extracted ---
c
      call spcset (ierr) 
      if( ierr .NE. ISUCES ) goto 9999
c
c  --- call routine to read the boundary header and store the
c      data in common ---
c
      call filbnd (ierr)
      if( ierr .NE. ISUCES ) goto 9999
c
c  --- if doing a time series plot, call routine to 
c      read the station file ---
c
cgmw      if( exttyp .EQ. TIMSER ) then
cgmw         call rdstn (ierr)
cgmw         if( ierr .NE. ISUCES ) goto 9999
cgmw      endif
cgmw
      if ((exttyp .EQ. XYHOUR) .OR. (exttyp .EQ. XYMAX)) then
        level = klayer
        lvltyp = 'layer'
      else if ((exttyp .EQ. XZHOUR) .OR. (exttyp .EQ. XZMAX)) then
        level = irow
        lvltyp = 'row'
      else if ((exttyp .EQ. YZHOUR) .OR. (exttyp .EQ. YZMAX)) then
        level = jcol 
        lvltyp = 'column'
      else
        level = 1 
        lvltyp = 'layer'
      endif
      totday = 0.
c
c  --- set flag for doing maxes or sums ---
c
      lmax = .FALSE.
      if( exttyp .EQ. XYMAX ) lmax = .TRUE. 
      if( exttyp .EQ. XZMAX ) lmax = .TRUE.
      if( exttyp .EQ. YZMAX ) lmax = .TRUE.
      lzero = .TRUE.
      if( exttyp .EQ. XYMAX ) lzero = .FALSE. 
      if( exttyp .EQ. XZMAX ) lzero = .FALSE.
      if( exttyp .EQ. YZMAX ) lzero = .FALSE.
      if( exttyp .EQ. EMISS ) lzero = .FALSE.
      if( exttyp .EQ. PTSRCE ) lzero = .FALSE.
c
c  --- process the next hour ---
c
      ihour = 0
      lfirst = .TRUE.
  111 continue
c
c  --- increment the counter for the hours read ---
c
      ihour = ihour + 1
      lusehr = .TRUE.
      if( ihour .LT. istart ) lusehr = .FALSE.
      if( MOD( (ihour-istart), inter ) .NE. 0 ) lusehr = .FALSE.
c
c  --- call routine to zero out the arrays ---
c
      call zeros (cncgrd,MXCELL*MXCELL*MXLAYR)
      call zeros (cnctmp,MXCELL*MXCELL*MXLAYR)
      if( lzero ) call zeros (conc2d,MXCELL*MXCELL)
c
c  --- read the hourly concentrations from the coarse grid file ----
c      puts coarse in cnctmp
c
      if( avgtyp .EQ. COARSE .OR. avgtyp .EQ. ALL ) then
         if( exttyp .EQ. PTSRCE ) then
            call rdhrpt (ierr,cnctmp,idate,ibeghr)
         else
            call rdhrcg (ierr,cnctmp,idate,ibeghr)
         endif
         if( ierr .EQ. IEOF ) goto 222
         if( ierr .NE. ISUCES ) goto 9999
         if( exttyp .EQ. EMISS .OR. exttyp .EQ. PTSRCE ) then
            write(IOWSTD,'(1X,A,T30,2I10)') 'Read emission file: ',
     &                                   idate,ibeghr
         else
            write(IOWSTD,'(1X,A,T30,2I10)') 'Read COARSE grid file: ',
     &                                   idate,ibeghr
         endif
c
c  --- fill cnctmp into cncgrd for COARSE extraction
c
         if( lusehr .AND. avgtyp .EQ. COARSE ) then
            call filfin (cncgrd,cnctmp,0)
         endif
c
c  --- read the height/pressure data for the coarse grid if vertical
c      sections are requested ---
c
         if( exttyp .EQ. XZMAX .OR. exttyp .EQ. XZHOUR .OR.
     &       exttyp .EQ. YZMAX .OR. exttyp .EQ. YZHOUR )  then
            call readzp (0,lfirst,idtbeg,ibeghr,nxgrid(0),nygrid(0),
     &                   nlgrid(0))
         endif
      endif
c
c  --- loop over the grids in FINE grid file ---
c
      if( avgtyp .EQ. FINE .OR. avgtyp .EQ. ALL ) then
c
c  --- interpolate coarse grid data to finest mesh and put into cncgrd
c
         if( lusehr .and. avgtyp .EQ. ALL ) 
     &      call crs2fin (cncgrd,cnctmp,0)
c
c  --- read the height/pressure data for the fine grids if vertical
c      sections are requested ---
c
         if( exttyp .EQ. XZMAX .OR. exttyp .EQ. XZHOUR .OR.
     &       exttyp .EQ. YZMAX .OR. exttyp .EQ. YZHOUR )  then
            do igrd=1,ngrid
              call readzp (igrd,lfirst,idtbeg,ibeghr,nxgrid(igrd),
     &                     nygrid(igrd),nlgrid(igrd))
            enddo
         endif
c
c  --- read the height/pressure data for all grids, and coarse grid
c      temperature data interpolated to all grids, if doing XY* ALL ALOFT
c      extraction ---
c
         if( (exttyp .EQ. XYMAX .OR. exttyp .EQ. XYHOUR) .AND.
     &       avgtyp .EQ. ALL .AND. laytyp .EQ. ALOFT ) then 
            do igrd=0,ngrid
              call readzp (igrd,lfirst,idtbeg,ibeghr,nxgrid(igrd),
     &                     nygrid(igrd),nlgrid(igrd))
            enddo
            call rdtmpr (idtbeg,ibeghr,nxgrid(0),nygrid(0),nlgrid(0))
         endif
c
         do 10 igrd=1,ngrid
c
c  --- call routine to zero out the array ---
c
           call zeros(cnctmp,MXCELL*MXCELL*MXLAYR)
c
c  --- read the hourly concentrations from the fine grid file ---
c
           call rdhrfg(ierr,cnctmp,idatfg,ibegfg,igrd)
           if( ierr .EQ. IEOF ) goto 222
           if( ierr .NE. ISUCES ) goto 9999
           if( avgtyp .EQ. FINE .AND. grdnum .NE. igrd) goto 10
c
c  --- vertically aggregate fine grid layers if ALL ALOFT extraction ---
c
           if( (exttyp .EQ. XYMAX .OR. exttyp .EQ. XYHOUR) .AND.
     &         avgtyp .EQ. ALL .AND. laytyp .EQ. ALOFT ) then
              call vertag (igrd,nxgrid(igrd),nygrid(igrd),nlgrid(igrd),
     &                     cnctmp)
           endif
c
c  --- vertically interpolate if doing vertical cross sections ---
c
cae        if( exttyp .EQ. XZMAX .OR. exttyp .EQ. XZHOUR .OR.
cae  &         exttyp .EQ. YZMAX .OR. exttyp .EQ. YZHOUR) )  then
cae           call vertinp ()
cae        endif
c
           if( lusehr ) then
              if( nmesh(igrd) .EQ. 1 ) then
c
c  ---  directly places values without interpolation
c
                 call filfin(cncgrd,cnctmp,igrd)
              else
c
c  ---  interpolates the grid data to the fine grid resolution ----
c
                 call crs2fin(cncgrd,cnctmp,igrd)
              endif
           endif
   10    continue
         if( avgtyp .EQ. FINE ) then
            ibeghr = ibegfg
            idate = idatfg
         endif
         write(IOWSTD,'(1X,A,T30,2I10)') 'Read FINE grid file: ',
     &                                          idatfg,ibegfg
      endif
cgmw
cgmw        if (exttyp .EQ. TIMSER) then
cgmw          call rdstn(concspec, ierr)
cgmw          goto 2000
cgmw        endif
cgmw
c
c  --- fill 2-D array with sums or maxes ---
c
      if( avgtyp .EQ. COARSE .OR. avgtyp .EQ. ALL ) then
         igrd = 0
      else
         igrd = grdnum
      endif
c
      totems = 0.
      zmin = 999999.
      zmax = -999999.
      do j = 1,nygrid(igrd)*nmesh(igrd)
        do i = 1,nxgrid(igrd)*nmesh(igrd)
          if( lmax ) then
             conc2d(i,j) = MAX(conc2d(i,j),cncgrd(i,j,klayer))
          else
             conc2d(i,j) = conc2d(i,j) + cncgrd(i,j,klayer)
          endif
          totday = totday + cncgrd(i,j,klayer) * untfac
          totems = totems + cncgrd(i,j,klayer) * untfac
          if( cncgrd(i,j,klayer) .GT. 0. ) 
     &          zmin = AMIN1(zmin,cncgrd(i,j,klayer)*untfac)
          zmax = AMAX1(zmax,cncgrd(i,j,klayer)*untfac)
        enddo 
      enddo 
c
c  --- if doing an emissions file, echo total for this hour,
c      otherwise echo the min and max value  ---
c
      if( exttyp .EQ. EMISS .OR. exttyp .EQ. PTSRCE ) then
          write(IOWSTD,'(20X,3A,F20.1,1X,A)') 'Total for ',
     &                       spname(:strlen(spname)),' ',totems,untstr
      else
          write(IOWSTD,'(20X,3A,F20.8,1X,A)') 'Minimum for ',
     &                         spname(:strlen(spname)),' ',zmin,untstr
          write(IOWSTD,'(20X,3A,F20.8,1X,A)') 'Maximum for ',
     &                         spname(:strlen(spname)),' ',zmax,untstr
      endif
c
c  --- if extraction type is XYHOUR and using this hour,
c      write to the output file ----
c 
        
      if( exttyp .EQ. XYHOUR .AND. lusehr ) then
         if( outtyp .EQ. ASCII ) then
            call wrtgrd(ierr,conc2d,IOWGRD,grxorg(igrd),gryorg(igrd),
     &           nxgrid(igrd)*nmesh(igrd),nygrid(igrd)*nmesh(igrd),
     &                      grdelx(igrd),grdely(igrd),nmesh(igrd),
     &                          spname,untstr,untfac,ndec,
     &                                 idate,ibeghr,level,lvltyp) 
            if( ierr .NE. ISUCES ) goto 9999
         else
            if( lfirst ) then
               call wrthdr(ierr,IOWGRD,grxorg(igrd),gryorg(igrd),
     &              nxgrid(igrd)*nmesh(igrd),nygrid(igrd)*nmesh(igrd),
     &                         grdelx(igrd),grdely(igrd),spname)
               if( ierr .NE. ISUCES ) goto 9999
            endif
            call wrtavg(ierr,conc2d,IOWGRD,nxgrid(igrd)*nmesh(igrd),
     &           nygrid(igrd)*nmesh(igrd),spname,idate,ibeghr,untfac)
            if( ierr .NE. ISUCES ) goto 9999
         endif
      endif
      lfirst = .FALSE.
      goto 111
  222 continue
c
c  --- if we've been summing or maxing, now's the time to write output ----
c
      if( avgtyp .EQ. COARSE .OR. avgtyp .EQ. ALL ) then
         igrd = 0
      else
         igrd = grdnum
      endif
      if( .NOT. lzero ) then
         if( outtyp .EQ. ASCII ) then
            if( exttyp .NE. PTSRCE ) then
               call wrtgrd(ierr,conc2d,IOWGRD,grxorg(igrd),gryorg(igrd),
     &              nxgrid(igrd)*nmesh(igrd),nygrid(igrd)*nmesh(igrd),
     &                       grdelx(igrd),grdely(igrd),nmesh(igrd),
     &                           spname,untstr,untfac,ndec,
     &                                  idate,ibeghr,level,lvltyp) 
            else
               call wrtdat(ierr,conc2d,IOWGRD,grxorg(igrd),gryorg(igrd),
     &                nxgrid(igrd)*nmesh(igrd),nygrid(igrd)*nmesh(igrd),
     &                    grdelx(igrd),grdely(igrd),nmesh(igrd),untfac)
c
            endif
         else
            call wrthdr(ierr,IOWGRD,grxorg(igrd),gryorg(igrd),
     &              nxgrid(igrd)*nmesh(igrd),nygrid(igrd)*nmesh(igrd),
     &                         grdelx(igrd),grdely(igrd),spname)
            if( ierr .NE. ISUCES ) goto 9999
            call wrtavg(ierr,conc2d,IOWGRD,nxgrid(igrd)*nmesh(igrd),
     &           nygrid(igrd)*nmesh(igrd),spname,idate,ibeghr,untfac)
            if( ierr .NE. ISUCES ) goto 9999
         endif
      endif
      if( exttyp .EQ. EMISS .OR. exttyp .EQ. PTSRCE ) then
           write(IOWSTD,'(20X,3A,F20.8)') 'Daily total for ',
     &                               spname(:strlen(spname)),' ',totday
      endif
c
      write(IOWSTD,'(/,2X,3A)') '--- Normal completion of ',VERSON,'---'
c
c-----------------------------------------------------------------------
c   Return point:
c-----------------------------------------------------------------------
c
 9999 continue
      end
